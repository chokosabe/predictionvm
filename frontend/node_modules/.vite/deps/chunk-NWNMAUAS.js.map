{
  "version": 3,
  "sources": ["../../lossless-json/src/config.ts", "../../lossless-json/src/utils.ts", "../../lossless-json/src/LosslessNumber.ts", "../../lossless-json/src/numberParsers.ts", "../../lossless-json/src/revive.ts", "../../lossless-json/src/parse.ts", "../../lossless-json/src/stringify.ts", "../../lossless-json/src/reviveDate.ts"],
  "sourcesContent": ["interface ConfigOptional {\n  circularRefs?: boolean\n}\n\ninterface Config extends ConfigOptional {\n  circularRefs: boolean\n}\n\n/**\n * Get and/or set configuration options\n * @deprecated There is no config anymore\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport function config(options?: ConfigOptional): Config {\n  // Backward compatibility warning for v1.x\n  throw new Error(\n    'config is deprecated, support for circularRefs is removed from the library. ' +\n      'If you encounter circular references in your data structures, ' +\n      'please rethink your datastructures: ' +\n      'better prevent circular references in the first place.'\n  )\n}\n", "/**\n * Test whether a string contains an integer number\n */\nexport function isInteger(value: string): boolean {\n  return INTEGER_REGEX.test(value)\n}\n\nconst INTEGER_REGEX = /^-?[0-9]+$/\n\n/**\n * Test whether a string contains a number\n * http://stackoverflow.com/questions/13340717/json-numbers-regular-expression\n */\nexport function isNumber(value: string): boolean {\n  return NUMBER_REGEX.test(value)\n}\n\nconst NUMBER_REGEX = /^-?(?:0|[1-9]\\d*)(?:\\.\\d+)?(?:[eE][+-]?\\d+)?$/\n\n/**\n * Test whether a string can be safely represented with a number\n * without information loss.\n *\n * When approx is true, floating point numbers that lose a few digits but\n * are still approximately equal in value are considered safe too.\n * Integer numbers must still be exactly equal.\n */\nexport function isSafeNumber(\n  value: string,\n  config?: {\n    approx: boolean\n  }\n): boolean {\n  const num = parseFloat(value)\n  const str = String(num)\n\n  const v = extractSignificantDigits(value)\n  const s = extractSignificantDigits(str)\n\n  if (v === s) {\n    return true\n  }\n\n  if (config?.approx === true) {\n    // A value is approximately equal when:\n    // 1. it is a floating point number, not an integer\n    // 2. it has at least 14 digits\n    // 3. the first 14 digits are equal\n    const requiredDigits = 14\n    if (\n      !isInteger(value) &&\n      s.length >= requiredDigits &&\n      v.startsWith(s.substring(0, requiredDigits))\n    ) {\n      return true\n    }\n  }\n\n  return false\n}\n\nexport enum UnsafeNumberReason {\n  underflow = 'underflow',\n  overflow = 'overflow',\n  truncate_integer = 'truncate_integer',\n  truncate_float = 'truncate_float'\n}\n\n/**\n * When the provided value is an unsafe number, describe what the reason is:\n * overflow, underflow, truncate_integer, or truncate_float.\n * Returns undefined when the value is safe.\n */\nexport function getUnsafeNumberReason(value: string): UnsafeNumberReason | undefined {\n  if (isSafeNumber(value, { approx: false })) {\n    return undefined\n  }\n\n  if (isInteger(value)) {\n    return UnsafeNumberReason.truncate_integer\n  }\n\n  const num = parseFloat(value)\n  if (!isFinite(num)) {\n    return UnsafeNumberReason.overflow\n  }\n\n  if (num === 0) {\n    return UnsafeNumberReason.underflow\n  }\n\n  return UnsafeNumberReason.truncate_float\n}\n\n/**\n * Convert a string into a number when it is safe to do so.\n * Throws an error otherwise, explaining the reason.\n */\nexport function toSafeNumberOrThrow(\n  value: string,\n  config?: {\n    approx: boolean\n  }\n): number {\n  const number = parseFloat(value)\n\n  const unsafeReason = getUnsafeNumberReason(value)\n  if (\n    config?.approx === true\n      ? unsafeReason && unsafeReason !== UnsafeNumberReason.truncate_float\n      : unsafeReason\n  ) {\n    const unsafeReasonText = unsafeReason?.replace(/_\\w+$/, '')\n    throw new Error(\n      'Cannot safely convert to number: ' +\n        `the value '${value}' would ${unsafeReasonText} and become ${number}`\n    )\n  }\n\n  return number\n}\n\n/**\n * Get the significant digits of a number.\n *\n * For example:\n *   '2.34' returns '234'\n *   '-77' returns '77'\n *   '0.003400' returns '34'\n *   '120.5e+30' returns '1205'\n **/\nexport function extractSignificantDigits(value: string): string {\n  return (\n    value\n      // from \"-0.250e+30\" to \"-0.250\"\n      .replace(EXPONENTIAL_PART_REGEX, '')\n\n      // from \"-0.250\" to \"-0250\"\n      .replace(DOT_REGEX, '')\n\n      // from \"-0250\" to \"-025\"\n      .replace(TRAILING_ZEROS_REGEX, '')\n\n      // from \"-025\" to \"25\"\n      .replace(LEADING_MINUS_AND_ZEROS_REGEX, '')\n  )\n}\n\nconst EXPONENTIAL_PART_REGEX = /[eE][+-]?\\d+$/\nconst LEADING_MINUS_AND_ZEROS_REGEX = /^-?(0*)?/\nconst DOT_REGEX = /\\./\nconst TRAILING_ZEROS_REGEX = /0+$/\n", "import {\n  extractSignificantDigits,\n  getUnsafeNumberReason,\n  isInteger,\n  isNumber,\n  UnsafeNumberReason\n} from './utils.js'\n\n/**\n * A lossless number. Stores its numeric value as string\n */\nexport class LosslessNumber {\n  // numeric value as string\n  value: string\n\n  // type information\n  isLosslessNumber = true\n\n  constructor(value: string) {\n    if (!isNumber(value)) {\n      throw new Error('Invalid number (value: \"' + value + '\")')\n    }\n\n    this.value = value\n  }\n\n  /**\n   * Get the value of the LosslessNumber as number or bigint.\n   *\n   * - a number is returned for safe numbers and decimal values that only lose some insignificant digits\n   * - a bigint is returned for big integer numbers\n   * - an Error is thrown for values that will overflow or underflow\n   *\n   * Note that you can implement your own strategy for conversion by just getting the value as string\n   * via .toString(), and using util functions like isInteger, isSafeNumber, getUnsafeNumberReason,\n   * and toSafeNumberOrThrow to convert it to a numeric value.\n   */\n  valueOf(): number | bigint {\n    const unsafeReason = getUnsafeNumberReason(this.value)\n\n    // safe or truncate_float\n    if (unsafeReason === undefined || unsafeReason === UnsafeNumberReason.truncate_float) {\n      return parseFloat(this.value)\n    }\n\n    // truncate_integer\n    if (isInteger(this.value)) {\n      return BigInt(this.value)\n    }\n\n    // overflow or underflow\n    throw new Error(\n      'Cannot safely convert to number: ' +\n        `the value '${this.value}' would ${unsafeReason} and become ${parseFloat(this.value)}`\n    )\n  }\n\n  /**\n   * Get the value of the LosslessNumber as string.\n   */\n  toString(): string {\n    return this.value\n  }\n\n  // Note: we do NOT implement a .toJSON() method, and you should not implement\n  // or use that, it cannot safely turn the numeric value in the string into\n  // stringified JSON since it has to be parsed into a number first.\n}\n\n/**\n * Test whether a value is a LosslessNumber\n */\nexport function isLosslessNumber(value: unknown): value is LosslessNumber {\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  return (value && typeof value === 'object' && value.isLosslessNumber === true) || false\n}\n\n/**\n * Convert a number into a LosslessNumber if this is possible in a safe way\n * If the value has too many digits, or is NaN or Infinity, an error will be thrown\n */\nexport function toLosslessNumber(value: number): LosslessNumber {\n  if (extractSignificantDigits(value + '').length > 15) {\n    throw new Error(\n      'Invalid number: contains more than 15 digits and is most likely truncated and unsafe by itself ' +\n        `(value: ${value})`\n    )\n  }\n\n  if (isNaN(value)) {\n    throw new Error('Invalid number: NaN')\n  }\n\n  if (!isFinite(value)) {\n    throw new Error('Invalid number: ' + value)\n  }\n\n  return new LosslessNumber(String(value))\n}\n", "import { LosslessNumber } from './LosslessNumber.js'\nimport { isInteger } from './utils.js'\n\nexport function parseLosslessNumber(value: string): LosslessNumber {\n  return new LosslessNumber(value)\n}\n\nexport function parseNumberAndBigInt(value: string): number | bigint {\n  return isInteger(value) ? BigInt(value) : parseFloat(value)\n}\n", "import { isLosslessNumber } from './LosslessNumber.js'\nimport type { GenericObject, Reviver } from './types'\n\n/**\n * Revive a json object.\n * Applies the reviver function recursively on all values in the JSON object.\n * @param json   A JSON Object, Array, or value\n * @param reviver\n *              A reviver function invoked with arguments `key` and `value`,\n *              which must return a replacement value. The function context\n *              (`this`) is the Object or Array that contains the currently\n *              handled value.\n */\nexport function revive(json: unknown, reviver: Reviver): unknown {\n  return reviveValue({ '': json }, '', json, reviver)\n}\n\n/**\n * Revive a value\n */\nfunction reviveValue(\n  context: GenericObject<unknown> | Array<unknown>,\n  key: string,\n  value: unknown,\n  reviver: Reviver\n): unknown {\n  if (Array.isArray(value)) {\n    return reviver.call(context, key, reviveArray(value, reviver))\n  } else if (value && typeof value === 'object' && !isLosslessNumber(value)) {\n    // note the special case for LosslessNumber,\n    // we don't want to iterate over the internals of a LosslessNumber\n    return reviver.call(context, key, reviveObject(value as GenericObject<unknown>, reviver))\n  } else {\n    return reviver.call(context, key, value)\n  }\n}\n\n/**\n * Revive the properties of an object\n */\nfunction reviveObject(object: GenericObject<unknown>, reviver: Reviver) {\n  Object.keys(object).forEach((key) => {\n    const value = reviveValue(object, key, object[key], reviver)\n    if (value !== undefined) {\n      object[key] = value\n    } else {\n      delete object[key]\n    }\n  })\n\n  return object\n}\n\n/**\n * Revive the properties of an Array\n */\nfunction reviveArray(array: Array<unknown>, reviver: Reviver): Array<unknown> {\n  for (let i = 0; i < array.length; i++) {\n    array[i] = reviveValue(array, i + '', array[i], reviver)\n  }\n\n  return array\n}\n", "import { parseLosslessNumber } from './numberParsers.js'\nimport { revive } from './revive.js'\nimport type { NumberParser, Reviver } from './types'\nimport { GenericObject } from './types'\n\n/**\n * The LosslessJSON.parse() method parses a string as JSON, optionally transforming\n * the value produced by parsing.\n *\n * The parser is based on the parser of Tan Li Hou shared in\n * https://lihautan.com/json-parser-with-javascript/\n *\n * @param text\n * The string to parse as JSON. See the JSON object for a description of JSON syntax.\n *\n * @param [reviver]\n * If a function, prescribes how the value originally produced by parsing is\n * transformed, before being returned.\n *\n * @param [parseNumber=parseLosslessNumber]\n * Pass a custom number parser. Input is a string, and the output can be unknown\n * numeric value: number, bigint, LosslessNumber, or a custom BigNumber library.\n *\n * @returns Returns the Object corresponding to the given JSON text.\n *\n * @throws Throws a SyntaxError exception if the string to parse is not valid JSON.\n */\nexport function parse(\n  text: string,\n  reviver?: Reviver | null,\n  parseNumber: NumberParser = parseLosslessNumber\n): unknown {\n  let i = 0\n  const value = parseValue()\n  expectValue(value)\n  expectEndOfInput()\n\n  return reviver ? revive(value, reviver) : value\n\n  function parseObject(): GenericObject<unknown> | undefined {\n    if (text.charCodeAt(i) === codeOpeningBrace) {\n      i++\n      skipWhitespace()\n\n      const object: GenericObject<unknown> = {}\n      let initial = true\n      while (i < text.length && text.charCodeAt(i) !== codeClosingBrace) {\n        if (!initial) {\n          eatComma()\n          skipWhitespace()\n        } else {\n          initial = false\n        }\n\n        const start = i\n\n        const key = parseString()\n        if (key === undefined) {\n          throwObjectKeyExpected()\n          return // To make TS happy\n        }\n\n        skipWhitespace()\n        eatColon()\n        const value = parseValue()\n\n        if (value === undefined) {\n          throwObjectValueExpected()\n          return // To make TS happy\n        }\n\n        // TODO: test deep equal instead of strict equal\n        if (Object.prototype.hasOwnProperty.call(object, key) && !isDeepEqual(value, object[key])) {\n          // Note that we could also test `if(key in object) {...}`\n          // or `if (object[key] !== 'undefined') {...}`, but that is slower.\n          throwDuplicateKey(key, start + 1)\n        }\n\n        object[key] = value\n      }\n\n      if (text.charCodeAt(i) !== codeClosingBrace) {\n        throwObjectKeyOrEndExpected()\n      }\n      i++\n\n      return object\n    }\n  }\n\n  function parseArray(): Array<unknown> | unknown {\n    if (text.charCodeAt(i) === codeOpeningBracket) {\n      i++\n      skipWhitespace()\n\n      const array = []\n      let initial = true\n      while (i < text.length && text.charCodeAt(i) !== codeClosingBracket) {\n        if (!initial) {\n          eatComma()\n        } else {\n          initial = false\n        }\n\n        const value = parseValue()\n        expectArrayItem(value)\n        array.push(value)\n      }\n\n      if (text.charCodeAt(i) !== codeClosingBracket) {\n        throwArrayItemOrEndExpected()\n      }\n      i++\n\n      return array\n    }\n  }\n\n  function parseValue(): unknown {\n    skipWhitespace()\n\n    const value =\n      parseString() ??\n      parseNumeric() ??\n      parseObject() ??\n      parseArray() ??\n      parseKeyword('true', true) ??\n      parseKeyword('false', false) ??\n      parseKeyword('null', null)\n\n    skipWhitespace()\n\n    return value\n  }\n\n  function parseKeyword(name: string, value: unknown): unknown | undefined {\n    if (text.slice(i, i + name.length) === name) {\n      i += name.length\n      return value\n    }\n  }\n\n  function skipWhitespace() {\n    while (isWhitespace(text.charCodeAt(i))) {\n      i++\n    }\n  }\n\n  function parseString() {\n    if (text.charCodeAt(i) === codeDoubleQuote) {\n      i++\n      let result = ''\n      while (i < text.length && text.charCodeAt(i) !== codeDoubleQuote) {\n        if (text.charCodeAt(i) === codeBackslash) {\n          const char = text[i + 1]\n          const escapeChar = escapeCharacters[char]\n          if (escapeChar !== undefined) {\n            result += escapeChar\n            i++\n          } else if (char === 'u') {\n            if (\n              isHex(text.charCodeAt(i + 2)) &&\n              isHex(text.charCodeAt(i + 3)) &&\n              isHex(text.charCodeAt(i + 4)) &&\n              isHex(text.charCodeAt(i + 5))\n            ) {\n              result += String.fromCharCode(parseInt(text.slice(i + 2, i + 6), 16))\n              i += 5\n            } else {\n              throwInvalidUnicodeCharacter(i)\n            }\n          } else {\n            throwInvalidEscapeCharacter(i)\n          }\n        } else {\n          if (isValidStringCharacter(text.charCodeAt(i))) {\n            result += text[i]\n          } else {\n            throwInvalidCharacter(text[i])\n          }\n        }\n        i++\n      }\n      expectEndOfString()\n      i++\n      return result\n    }\n  }\n\n  function parseNumeric() {\n    const start = i\n    if (text.charCodeAt(i) === codeMinus) {\n      i++\n      expectDigit(start)\n    }\n\n    if (text.charCodeAt(i) === codeZero) {\n      i++\n    } else if (isNonZeroDigit(text.charCodeAt(i))) {\n      i++\n      while (isDigit(text.charCodeAt(i))) {\n        i++\n      }\n    }\n\n    if (text.charCodeAt(i) === codeDot) {\n      i++\n      expectDigit(start)\n      while (isDigit(text.charCodeAt(i))) {\n        i++\n      }\n    }\n\n    if (text.charCodeAt(i) === codeLowercaseE || text.charCodeAt(i) === codeUppercaseE) {\n      i++\n      if (text.charCodeAt(i) === codeMinus || text.charCodeAt(i) === codePlus) {\n        i++\n      }\n      expectDigit(start)\n      while (isDigit(text.charCodeAt(i))) {\n        i++\n      }\n    }\n\n    if (i > start) {\n      return parseNumber(text.slice(start, i))\n    }\n  }\n\n  function eatComma() {\n    if (text.charCodeAt(i) !== codeComma) {\n      throw new SyntaxError(`Comma ',' expected after value ${gotAt()}`)\n    }\n    i++\n  }\n\n  function eatColon() {\n    if (text.charCodeAt(i) !== codeColon) {\n      throw new SyntaxError(`Colon ':' expected after property name ${gotAt()}`)\n    }\n    i++\n  }\n\n  function expectValue(value: unknown) {\n    if (value === undefined) {\n      throw new SyntaxError(`JSON value expected ${gotAt()}`)\n    }\n  }\n\n  function expectArrayItem(value: unknown) {\n    if (value === undefined) {\n      throw new SyntaxError(`Array item expected ${gotAt()}`)\n    }\n  }\n\n  function expectEndOfInput() {\n    if (i < text.length) {\n      throw new SyntaxError(`Expected end of input ${gotAt()}`)\n    }\n  }\n\n  function expectDigit(start: number) {\n    if (!isDigit(text.charCodeAt(i))) {\n      const numSoFar = text.slice(start, i)\n      throw new SyntaxError(`Invalid number '${numSoFar}', expecting a digit ${gotAt()}`)\n    }\n  }\n\n  function expectEndOfString() {\n    if (text.charCodeAt(i) !== codeDoubleQuote) {\n      throw new SyntaxError(`End of string '\"' expected ${gotAt()}`)\n    }\n  }\n\n  function throwObjectKeyExpected() {\n    throw new SyntaxError(`Quoted object key expected ${gotAt()}`)\n  }\n\n  function throwDuplicateKey(key: string, pos: number) {\n    throw new SyntaxError(`Duplicate key '${key}' encountered at position ${pos}`)\n  }\n\n  function throwObjectKeyOrEndExpected() {\n    throw new SyntaxError(`Quoted object key or end of object '}' expected ${gotAt()}`)\n  }\n\n  function throwArrayItemOrEndExpected() {\n    throw new SyntaxError(`Array item or end of array ']' expected ${gotAt()}`)\n  }\n\n  function throwInvalidCharacter(char: string) {\n    throw new SyntaxError(`Invalid character '${char}' ${pos()}`)\n  }\n\n  function throwInvalidEscapeCharacter(start: number) {\n    const chars = text.slice(start, start + 2)\n    throw new SyntaxError(`Invalid escape character '${chars}' ${pos()}`)\n  }\n\n  function throwObjectValueExpected() {\n    throw new SyntaxError(`Object value expected after ':' ${pos()}`)\n  }\n\n  function throwInvalidUnicodeCharacter(start: number) {\n    const chars = text.slice(start, start + 6)\n    throw new SyntaxError(`Invalid unicode character '${chars}' ${pos()}`)\n  }\n\n  // zero based character position\n  function pos(): string {\n    return `at position ${i}`\n  }\n\n  function got(): string {\n    return i < text.length ? `but got '${text[i]}'` : 'but reached end of input'\n  }\n\n  function gotAt(): string {\n    return got() + ' ' + pos()\n  }\n}\n\nfunction isWhitespace(code: number): boolean {\n  return code === codeSpace || code === codeNewline || code === codeTab || code === codeReturn\n}\n\nfunction isHex(code: number): boolean {\n  return (\n    (code >= codeZero && code <= codeNine) ||\n    (code >= codeUppercaseA && code <= codeUppercaseF) ||\n    (code >= codeLowercaseA && code <= codeLowercaseF)\n  )\n}\n\nfunction isDigit(code: number): boolean {\n  return code >= codeZero && code <= codeNine\n}\n\nfunction isNonZeroDigit(code: number): boolean {\n  return code >= codeOne && code <= codeNine\n}\n\nexport function isValidStringCharacter(code: number): boolean {\n  return code >= 0x20 && code <= 0x10ffff\n}\n\nexport function isDeepEqual(a: unknown, b: unknown): boolean {\n  if (a === b) {\n    return true\n  }\n\n  if (Array.isArray(a) && Array.isArray(b)) {\n    return a.length === b.length && a.every((item, index) => isDeepEqual(item, b[index]))\n  }\n\n  if (isObject(a) && isObject(b)) {\n    const keys = [...new Set([...Object.keys(a), ...Object.keys(b)])]\n    return keys.every((key) => isDeepEqual(a[key], b[key]))\n  }\n\n  return false\n}\n\nfunction isObject(value: unknown): value is Record<string, unknown> {\n  return typeof value === 'object' && value !== null\n}\n\n// map with all escape characters\nconst escapeCharacters: GenericObject<string> = {\n  '\"': '\"',\n  '\\\\': '\\\\',\n  '/': '/',\n  b: '\\b',\n  f: '\\f',\n  n: '\\n',\n  r: '\\r',\n  t: '\\t'\n  // note that \\u is handled separately in parseString()\n}\n\nconst codeBackslash = 0x5c // \"\\\"\nconst codeOpeningBrace = 0x7b // \"{\"\nconst codeClosingBrace = 0x7d // \"}\"\nconst codeOpeningBracket = 0x5b // \"[\"\nconst codeClosingBracket = 0x5d // \"]\"\nconst codeSpace = 0x20 // \" \"\nconst codeNewline = 0xa // \"\\n\"\nconst codeTab = 0x9 // \"\\t\"\nconst codeReturn = 0xd // \"\\r\"\nconst codeDoubleQuote = 0x0022 // \"\nconst codePlus = 0x2b // \"+\"\nconst codeMinus = 0x2d // \"-\"\nconst codeZero = 0x30\nconst codeOne = 0x31\nconst codeNine = 0x39\nconst codeComma = 0x2c // \",\"\nconst codeDot = 0x2e // \".\" (dot, period)\nconst codeColon = 0x3a // \":\"\nexport const codeUppercaseA = 0x41 // \"A\"\nexport const codeLowercaseA = 0x61 // \"a\"\nexport const codeUppercaseE = 0x45 // \"E\"\nexport const codeLowercaseE = 0x65 // \"e\"\nexport const codeUppercaseF = 0x46 // \"F\"\nexport const codeLowercaseF = 0x66 // \"f\"\n", "import type { GenericObject, NumberStringifier, Replacer } from './types'\nimport { isNumber } from './utils.js'\n\n/**\n * The LosslessJSON.stringify() method converts a JavaScript value to a JSON string,\n * optionally replacing values if a replacer function is specified, or\n * optionally including only the specified properties if a replacer array is specified.\n *\n * @param value\n * The value to convert to a JSON string.\n *\n * @param [replacer]\n * A function that alters the behavior of the stringification process,\n * or an array of String and Number objects that serve as a whitelist for\n * selecting the properties of the value object to be included in the JSON string.\n * If this value is null or not provided, all properties of the object are\n * included in the resulting JSON string.\n *\n * @param [space]\n * A String or Number object that's used to insert white space into the output\n * JSON string for readability purposes. If this is a Number, it indicates the\n * number of space characters to use as white space; this number is capped at 10\n * if it's larger than that. Values less than 1 indicate that no space should be\n * used. If this is a String, the string (or the first 10 characters of the string,\n * if it's longer than that) is used as white space. If this parameter is not\n * provided (or is null), no white space is used.\n *\n * @param [numberStringifiers]\n * An optional list with additional number stringifiers, for example to serialize\n * a BigNumber. The output of the function must be valid stringified JSON.\n * When `undefined` is returned, the property will be deleted from the object.\n * The difference with using a `replacer` is that the output of a `replacer`\n * must be JSON and will be stringified afterwards, whereas the output of the\n * `numberStringifiers` is already stringified JSON.\n *\n * @returns Returns the string representation of the JSON object.\n */\nexport function stringify(\n  value: unknown,\n  replacer?: Replacer | null,\n  space?: number | string,\n  numberStringifiers?: NumberStringifier[]\n): string | undefined {\n  const resolvedSpace = resolveSpace(space)\n\n  const replacedValue =\n    typeof replacer === 'function' ? replacer.call({ '': value }, '', value) : value\n\n  return stringifyValue(replacedValue, '')\n\n  /**\n   * Stringify a value\n   */\n  function stringifyValue(value: unknown, indent: string | undefined): string | undefined {\n    if (Array.isArray(numberStringifiers)) {\n      const stringifier = numberStringifiers.find((item) => item.test(value))\n      if (stringifier) {\n        const str: unknown = stringifier.stringify(value)\n        if (typeof str !== 'string' || !isNumber(str)) {\n          throw new Error(\n            'Invalid JSON number: ' +\n              'output of a number stringifier must be a string containing a JSON number ' +\n              `(output: ${str})`\n          )\n        }\n        return str\n      }\n    }\n\n    // boolean, null, number, string, or date\n    if (\n      typeof value === 'boolean' ||\n      typeof value === 'number' ||\n      typeof value === 'string' ||\n      value === null ||\n      value instanceof Date ||\n      value instanceof Boolean ||\n      value instanceof Number ||\n      value instanceof String\n    ) {\n      return JSON.stringify(value)\n    }\n\n    // lossless number, the secret ingredient :)\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    if (value && value.isLosslessNumber) {\n      return value.toString()\n    }\n\n    // BigInt\n    if (typeof value === 'bigint') {\n      return value.toString()\n    }\n\n    // Array\n    if (Array.isArray(value)) {\n      return stringifyArray(value, indent)\n    }\n\n    // Object (test lastly!)\n    if (value && typeof value === 'object') {\n      return stringifyObject(value as GenericObject<unknown>, indent)\n    }\n\n    return undefined\n  }\n\n  /**\n   * Stringify an array\n   */\n  function stringifyArray(array: Array<unknown>, indent: string | undefined): string {\n    if (array.length === 0) {\n      return '[]'\n    }\n\n    const childIndent = resolvedSpace ? indent + resolvedSpace : undefined\n    let str = resolvedSpace ? '[\\n' : '['\n\n    for (let i = 0; i < array.length; i++) {\n      const item =\n        typeof replacer === 'function' ? replacer.call(array, String(i), array[i]) : array[i]\n\n      if (resolvedSpace) {\n        str += childIndent\n      }\n\n      if (typeof item !== 'undefined' && typeof item !== 'function') {\n        str += stringifyValue(item, childIndent)\n      } else {\n        str += 'null'\n      }\n\n      if (i < array.length - 1) {\n        str += resolvedSpace ? ',\\n' : ','\n      }\n    }\n\n    str += resolvedSpace ? '\\n' + indent + ']' : ']'\n    return str\n  }\n\n  /**\n   * Stringify an object\n   */\n  function stringifyObject(\n    object: GenericObject<unknown>,\n    indent: string | undefined\n  ): string | undefined {\n    if (typeof object.toJSON === 'function') {\n      return stringify(object.toJSON(), replacer, space, undefined)\n    }\n\n    const keys: string[] = Array.isArray(replacer) ? replacer.map(String) : Object.keys(object)\n\n    if (keys.length === 0) {\n      return '{}'\n    }\n\n    const childIndent = resolvedSpace ? indent + resolvedSpace : undefined\n    let first = true\n    let str = resolvedSpace ? '{\\n' : '{'\n\n    keys.forEach((key) => {\n      const value =\n        typeof replacer === 'function' ? replacer.call(object, key, object[key]) : object[key]\n\n      if (includeProperty(key, value)) {\n        if (first) {\n          first = false\n        } else {\n          str += resolvedSpace ? ',\\n' : ','\n        }\n\n        const keyStr = JSON.stringify(key)\n        str += resolvedSpace ? childIndent + keyStr + ': ' : keyStr + ':'\n\n        str += stringifyValue(value, childIndent)\n      }\n    })\n\n    str += resolvedSpace ? '\\n' + indent + '}' : '}'\n    return str\n  }\n\n  /**\n   * Test whether to include a property in a stringified object or not.\n   */\n  function includeProperty(key: string, value: unknown): boolean {\n    return typeof value !== 'undefined' && typeof value !== 'function' && typeof value !== 'symbol'\n  }\n}\n\n/**\n * Resolve a JSON stringify space:\n * replace a number with a string containing that number of spaces\n */\nfunction resolveSpace(space: number | string | undefined): string | undefined {\n  if (typeof space === 'number') {\n    return ' '.repeat(space)\n  }\n\n  if (typeof space === 'string' && space !== '') {\n    return space\n  }\n\n  return undefined\n}\n", "/**\n * Revive a string containing an ISO 8601 date string into a JavaScript `Date` object\n */\nexport function reviveDate(key: string, value: unknown): Date | unknown {\n  return typeof value === 'string' && isoDateRegex.test(value) ? new Date(value) : value\n}\n\n// Matches strings like \"2022-08-25T09:39:19.288Z\"\nconst isoDateRegex = /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{3}Z$/\n"],
  "mappings": "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",
  "names": ["config", "options", "Error", "isInteger", "value", "INTEGER_REGEX", "test", "isNumber", "NUMBER_REGEX", "isSafeNumber", "config", "num", "parseFloat", "str", "String", "v", "extractSignificantDigits", "s", "approx", "requiredDigits", "length", "startsWith", "substring", "UnsafeNumberReason", "getUnsafeNumberReason", "undefined", "truncate_integer", "isFinite", "overflow", "underflow", "truncate_float", "toSafeNumberOrThrow", "number", "unsafeReason", "unsafeReasonText", "replace", "Error", "EXPONENTIAL_PART_REGEX", "DOT_REGEX", "TRAILING_ZEROS_REGEX", "LEADING_MINUS_AND_ZEROS_REGEX", "LosslessNumber", "constructor", "value", "isLosslessNumber", "isNumber", "Error", "valueOf", "unsafeReason", "getUnsafeNumberReason", "undefined", "UnsafeNumberReason", "truncate_float", "parseFloat", "isInteger", "BigInt", "toString", "toLosslessNumber", "extractSignificantDigits", "length", "isNaN", "isFinite", "String", "parseLosslessNumber", "value", "LosslessNumber", "parseNumberAndBigInt", "isInteger", "BigInt", "parseFloat", "revive", "json", "reviver", "reviveValue", "context", "key", "value", "Array", "isArray", "call", "reviveArray", "isLosslessNumber", "reviveObject", "object", "Object", "keys", "forEach", "undefined", "array", "i", "length", "parse", "text", "reviver", "parseNumber", "arguments", "length", "undefined", "parseLosslessNumber", "i", "value", "parseValue", "expectValue", "expectEndOfInput", "revive", "parseObject", "charCodeAt", "codeOpeningBrace", "skipWhitespace", "object", "initial", "codeClosingBrace", "eatComma", "start", "key", "parseString", "throwObjectKeyExpected", "eatColon", "throwObjectValueExpected", "Object", "prototype", "hasOwnProperty", "call", "isDeepEqual", "throwDuplicateKey", "throwObjectKeyOrEndExpected", "parseArray", "codeOpeningBracket", "array", "codeClosingBracket", "expectArrayItem", "push", "throwArrayItemOrEndExpected", "parseNumeric", "parseKeyword", "name", "slice", "isWhitespace", "codeDoubleQuote", "result", "codeBackslash", "char", "escapeChar", "escapeCharacters", "isHex", "String", "fromCharCode", "parseInt", "throwInvalidUnicodeCharacter", "throwInvalidEscapeCharacter", "isValidStringCharacter", "throwInvalidCharacter", "expectEndOfString", "codeMinus", "expectDigit", "codeZero", "isNonZeroDigit", "isDigit", "codeDot", "codeLowercaseE", "codeUppercaseE", "codePlus", "codeComma", "SyntaxError", "gotAt", "codeColon", "numSoFar", "pos", "chars", "got", "code", "codeSpace", "codeNewline", "codeTab", "codeReturn", "codeNine", "codeUppercaseA", "codeUppercaseF", "codeLowercaseA", "codeLowercaseF", "codeOne", "a", "b", "Array", "isArray", "every", "item", "index", "isObject", "keys", "Set", "f", "n", "r", "t", "stringify", "value", "replacer", "space", "numberStringifiers", "resolvedSpace", "resolveSpace", "replacedValue", "call", "stringifyValue", "indent", "Array", "isArray", "stringifier", "find", "item", "test", "str", "isNumber", "Error", "Date", "Boolean", "Number", "String", "JSON", "isLosslessNumber", "toString", "stringifyArray", "stringifyObject", "undefined", "array", "length", "childIndent", "i", "object", "toJSON", "keys", "map", "Object", "first", "forEach", "key", "includeProperty", "keyStr", "repeat", "reviveDate", "key", "value", "isoDateRegex", "test", "Date"]
}
