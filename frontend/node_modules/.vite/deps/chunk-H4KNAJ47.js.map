{
  "version": 3,
  "sources": ["../../hypersdk-client/node_modules/@noble/hashes/src/_assert.ts", "../../hypersdk-client/node_modules/@noble/hashes/src/crypto.ts", "../../hypersdk-client/node_modules/@noble/hashes/src/utils.ts", "../../hypersdk-client/node_modules/@noble/hashes/src/_md.ts", "../../hypersdk-client/node_modules/@noble/hashes/src/sha256.ts", "../../@scure/base/index.ts", "../../hypersdk-client/src/testdata/abi.abi.json", "../../hypersdk-client/src/Marshaler.ts"],
  "sourcesContent": ["function number(n: number) {\n  if (!Number.isSafeInteger(n) || n < 0) throw new Error(`positive integer expected, not ${n}`);\n}\n\nfunction bool(b: boolean) {\n  if (typeof b !== 'boolean') throw new Error(`boolean expected, not ${b}`);\n}\n\n// copied from utils\nexport function isBytes(a: unknown): a is Uint8Array {\n  return (\n    a instanceof Uint8Array ||\n    (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array')\n  );\n}\n\nfunction bytes(b: Uint8Array | undefined, ...lengths: number[]) {\n  if (!isBytes(b)) throw new Error('Uint8Array expected');\n  if (lengths.length > 0 && !lengths.includes(b.length))\n    throw new Error(`Uint8Array expected of length ${lengths}, not of length=${b.length}`);\n}\n\ntype Hash = {\n  (data: Uint8Array): Uint8Array;\n  blockLen: number;\n  outputLen: number;\n  create: any;\n};\nfunction hash(h: Hash) {\n  if (typeof h !== 'function' || typeof h.create !== 'function')\n    throw new Error('Hash should be wrapped by utils.wrapConstructor');\n  number(h.outputLen);\n  number(h.blockLen);\n}\n\nfunction exists(instance: any, checkFinished = true) {\n  if (instance.destroyed) throw new Error('Hash instance has been destroyed');\n  if (checkFinished && instance.finished) throw new Error('Hash#digest() has already been called');\n}\nfunction output(out: any, instance: any) {\n  bytes(out);\n  const min = instance.outputLen;\n  if (out.length < min) {\n    throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n  }\n}\n\nexport { number, bool, bytes, hash, exists, output };\n\nconst assert = { number, bool, bytes, hash, exists, output };\nexport default assert;\n", "// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// See utils.ts for details.\ndeclare const globalThis: Record<string, any> | undefined;\nexport const crypto =\n  typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;\n", "/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\nimport { crypto } from '@noble/hashes/crypto';\nimport { bytes as abytes } from './_assert.js';\n// export { isBytes } from './_assert.js';\n// We can't reuse isBytes from _assert, because somehow this causes huge perf issues\nexport function isBytes(a: unknown): a is Uint8Array {\n  return (\n    a instanceof Uint8Array ||\n    (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array')\n  );\n}\n\n// prettier-ignore\nexport type TypedArray = Int8Array | Uint8ClampedArray | Uint8Array |\n  Uint16Array | Int16Array | Uint32Array | Int32Array;\n\n// Cast array to different type\nexport const u8 = (arr: TypedArray) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nexport const u32 = (arr: TypedArray) =>\n  new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n\n// Cast array to view\nexport const createView = (arr: TypedArray) =>\n  new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n\n// The rotate right (circular right shift) operation for uint32\nexport const rotr = (word: number, shift: number) => (word << (32 - shift)) | (word >>> shift);\n// The rotate left (circular left shift) operation for uint32\nexport const rotl = (word: number, shift: number) =>\n  (word << shift) | ((word >>> (32 - shift)) >>> 0);\n\nexport const isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\n// The byte swap operation for uint32\nexport const byteSwap = (word: number) =>\n  ((word << 24) & 0xff000000) |\n  ((word << 8) & 0xff0000) |\n  ((word >>> 8) & 0xff00) |\n  ((word >>> 24) & 0xff);\n// Conditionally byte swap if on a big-endian platform\nexport const byteSwapIfBE = isLE ? (n: number) => n : (n: number) => byteSwap(n);\n\n// In place byte swap for Uint32Array\nexport function byteSwap32(arr: Uint32Array) {\n  for (let i = 0; i < arr.length; i++) {\n    arr[i] = byteSwap(arr[i]);\n  }\n}\n\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) =>\n  i.toString(16).padStart(2, '0')\n);\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes: Uint8Array): string {\n  abytes(bytes);\n  // pre-caching improves the speed 6x\n  let hex = '';\n  for (let i = 0; i < bytes.length; i++) {\n    hex += hexes[bytes[i]];\n  }\n  return hex;\n}\n\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 } as const;\nfunction asciiToBase16(char: number): number | undefined {\n  if (char >= asciis._0 && char <= asciis._9) return char - asciis._0;\n  if (char >= asciis._A && char <= asciis._F) return char - (asciis._A - 10);\n  if (char >= asciis._a && char <= asciis._f) return char - (asciis._a - 10);\n  return;\n}\n\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex: string): Uint8Array {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  const hl = hex.length;\n  const al = hl / 2;\n  if (hl % 2) throw new Error('padded hex string expected, got unpadded hex of length ' + hl);\n  const array = new Uint8Array(al);\n  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n    const n1 = asciiToBase16(hex.charCodeAt(hi));\n    const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n    if (n1 === undefined || n2 === undefined) {\n      const char = hex[hi] + hex[hi + 1];\n      throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n    }\n    array[ai] = n1 * 16 + n2;\n  }\n  return array;\n}\n\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nexport const nextTick = async () => {};\n\n// Returns control to thread each 'tick' ms to avoid blocking\nexport async function asyncLoop(iters: number, tick: number, cb: (i: number) => void) {\n  let ts = Date.now();\n  for (let i = 0; i < iters; i++) {\n    cb(i);\n    // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n    const diff = Date.now() - ts;\n    if (diff >= 0 && diff < tick) continue;\n    await nextTick();\n    ts += diff;\n  }\n}\n\n// Global symbols in both browsers and Node.js since v11\n// See https://github.com/microsoft/TypeScript/issues/31535\ndeclare const TextEncoder: any;\n\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nexport function utf8ToBytes(str: string): Uint8Array {\n  if (typeof str !== 'string') throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n  return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n\nexport type Input = Uint8Array | string;\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nexport function toBytes(data: Input): Uint8Array {\n  if (typeof data === 'string') data = utf8ToBytes(data);\n  abytes(data);\n  return data;\n}\n\n/**\n * Copies several Uint8Arrays into one.\n */\nexport function concatBytes(...arrays: Uint8Array[]): Uint8Array {\n  let sum = 0;\n  for (let i = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    abytes(a);\n    sum += a.length;\n  }\n  const res = new Uint8Array(sum);\n  for (let i = 0, pad = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    res.set(a, pad);\n    pad += a.length;\n  }\n  return res;\n}\n\n// For runtime check if class implements interface\nexport abstract class Hash<T extends Hash<T>> {\n  abstract blockLen: number; // Bytes per block\n  abstract outputLen: number; // Bytes in output\n  abstract update(buf: Input): this;\n  // Writes digest into buf\n  abstract digestInto(buf: Uint8Array): void;\n  abstract digest(): Uint8Array;\n  /**\n   * Resets internal state. Makes Hash instance unusable.\n   * Reset is impossible for keyed hashes if key is consumed into state. If digest is not consumed\n   * by user, they will need to manually call `destroy()` when zeroing is necessary.\n   */\n  abstract destroy(): void;\n  /**\n   * Clones hash instance. Unsafe: doesn't check whether `to` is valid. Can be used as `clone()`\n   * when no options are passed.\n   * Reasons to use `_cloneInto` instead of clone: 1) performance 2) reuse instance => all internal\n   * buffers are overwritten => causes buffer overwrite which is used for digest in some cases.\n   * There are no guarantees for clean-up because it's impossible in JS.\n   */\n  abstract _cloneInto(to?: T): T;\n  // Safe version that clones internal state\n  clone(): T {\n    return this._cloneInto();\n  }\n}\n\n/**\n * XOF: streaming API to read digest in chunks.\n * Same as 'squeeze' in keccak/k12 and 'seek' in blake3, but more generic name.\n * When hash used in XOF mode it is up to user to call '.destroy' afterwards, since we cannot\n * destroy state, next call can require more bytes.\n */\nexport type HashXOF<T extends Hash<T>> = Hash<T> & {\n  xof(bytes: number): Uint8Array; // Read 'bytes' bytes from digest stream\n  xofInto(buf: Uint8Array): Uint8Array; // read buf.length bytes from digest stream into buf\n};\n\nconst toStr = {}.toString;\ntype EmptyObj = {};\nexport function checkOpts<T1 extends EmptyObj, T2 extends EmptyObj>(\n  defaults: T1,\n  opts?: T2\n): T1 & T2 {\n  if (opts !== undefined && toStr.call(opts) !== '[object Object]')\n    throw new Error('Options should be object or undefined');\n  const merged = Object.assign(defaults, opts);\n  return merged as T1 & T2;\n}\n\nexport type CHash = ReturnType<typeof wrapConstructor>;\n\nexport function wrapConstructor<T extends Hash<T>>(hashCons: () => Hash<T>) {\n  const hashC = (msg: Input): Uint8Array => hashCons().update(toBytes(msg)).digest();\n  const tmp = hashCons();\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = () => hashCons();\n  return hashC;\n}\n\nexport function wrapConstructorWithOpts<H extends Hash<H>, T extends Object>(\n  hashCons: (opts?: T) => Hash<H>\n) {\n  const hashC = (msg: Input, opts?: T): Uint8Array => hashCons(opts).update(toBytes(msg)).digest();\n  const tmp = hashCons({} as T);\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (opts: T) => hashCons(opts);\n  return hashC;\n}\n\nexport function wrapXOFConstructorWithOpts<H extends HashXOF<H>, T extends Object>(\n  hashCons: (opts?: T) => HashXOF<H>\n) {\n  const hashC = (msg: Input, opts?: T): Uint8Array => hashCons(opts).update(toBytes(msg)).digest();\n  const tmp = hashCons({} as T);\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (opts: T) => hashCons(opts);\n  return hashC;\n}\n\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */\nexport function randomBytes(bytesLength = 32): Uint8Array {\n  if (crypto && typeof crypto.getRandomValues === 'function') {\n    return crypto.getRandomValues(new Uint8Array(bytesLength));\n  }\n  // Legacy Node.js compatibility\n  if (crypto && typeof crypto.randomBytes === 'function') {\n    return crypto.randomBytes(bytesLength);\n  }\n  throw new Error('crypto.getRandomValues must be defined');\n}\n", "import { exists, output } from './_assert.js';\nimport { Hash, createView, Input, toBytes } from './utils.js';\n\n/**\n * Polyfill for Safari 14\n */\nfunction setBigUint64(view: DataView, byteOffset: number, value: bigint, isLE: boolean): void {\n  if (typeof view.setBigUint64 === 'function') return view.setBigUint64(byteOffset, value, isLE);\n  const _32n = BigInt(32);\n  const _u32_max = BigInt(0xffffffff);\n  const wh = Number((value >> _32n) & _u32_max);\n  const wl = Number(value & _u32_max);\n  const h = isLE ? 4 : 0;\n  const l = isLE ? 0 : 4;\n  view.setUint32(byteOffset + h, wh, isLE);\n  view.setUint32(byteOffset + l, wl, isLE);\n}\n\n/**\n * Choice: a ? b : c\n */\nexport const Chi = (a: number, b: number, c: number) => (a & b) ^ (~a & c);\n\n/**\n * Majority function, true if any two inputs is true\n */\nexport const Maj = (a: number, b: number, c: number) => (a & b) ^ (a & c) ^ (b & c);\n\n/**\n * Merkle-Damgard hash construction base class.\n * Could be used to create MD5, RIPEMD, SHA1, SHA2.\n */\nexport abstract class HashMD<T extends HashMD<T>> extends Hash<T> {\n  protected abstract process(buf: DataView, offset: number): void;\n  protected abstract get(): number[];\n  protected abstract set(...args: number[]): void;\n  abstract destroy(): void;\n  protected abstract roundClean(): void;\n  // For partial updates less than block size\n  protected buffer: Uint8Array;\n  protected view: DataView;\n  protected finished = false;\n  protected length = 0;\n  protected pos = 0;\n  protected destroyed = false;\n\n  constructor(\n    readonly blockLen: number,\n    public outputLen: number,\n    readonly padOffset: number,\n    readonly isLE: boolean\n  ) {\n    super();\n    this.buffer = new Uint8Array(blockLen);\n    this.view = createView(this.buffer);\n  }\n  update(data: Input): this {\n    exists(this);\n    const { view, buffer, blockLen } = this;\n    data = toBytes(data);\n    const len = data.length;\n    for (let pos = 0; pos < len; ) {\n      const take = Math.min(blockLen - this.pos, len - pos);\n      // Fast path: we have at least one block in input, cast it to view and process\n      if (take === blockLen) {\n        const dataView = createView(data);\n        for (; blockLen <= len - pos; pos += blockLen) this.process(dataView, pos);\n        continue;\n      }\n      buffer.set(data.subarray(pos, pos + take), this.pos);\n      this.pos += take;\n      pos += take;\n      if (this.pos === blockLen) {\n        this.process(view, 0);\n        this.pos = 0;\n      }\n    }\n    this.length += data.length;\n    this.roundClean();\n    return this;\n  }\n  digestInto(out: Uint8Array) {\n    exists(this);\n    output(out, this);\n    this.finished = true;\n    // Padding\n    // We can avoid allocation of buffer for padding completely if it\n    // was previously not allocated here. But it won't change performance.\n    const { buffer, view, blockLen, isLE } = this;\n    let { pos } = this;\n    // append the bit '1' to the message\n    buffer[pos++] = 0b10000000;\n    this.buffer.subarray(pos).fill(0);\n    // we have less than padOffset left in buffer, so we cannot put length in\n    // current block, need process it and pad again\n    if (this.padOffset > blockLen - pos) {\n      this.process(view, 0);\n      pos = 0;\n    }\n    // Pad until full block byte with zeros\n    for (let i = pos; i < blockLen; i++) buffer[i] = 0;\n    // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n    // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n    // So we just write lowest 64 bits of that value.\n    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n    this.process(view, 0);\n    const oview = createView(out);\n    const len = this.outputLen;\n    // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n    if (len % 4) throw new Error('_sha2: outputLen should be aligned to 32bit');\n    const outLen = len / 4;\n    const state = this.get();\n    if (outLen > state.length) throw new Error('_sha2: outputLen bigger than state');\n    for (let i = 0; i < outLen; i++) oview.setUint32(4 * i, state[i], isLE);\n  }\n  digest() {\n    const { buffer, outputLen } = this;\n    this.digestInto(buffer);\n    const res = buffer.slice(0, outputLen);\n    this.destroy();\n    return res;\n  }\n  _cloneInto(to?: T): T {\n    to ||= new (this.constructor as any)() as T;\n    to.set(...this.get());\n    const { blockLen, buffer, length, finished, destroyed, pos } = this;\n    to.length = length;\n    to.pos = pos;\n    to.finished = finished;\n    to.destroyed = destroyed;\n    if (length % blockLen) to.buffer.set(buffer);\n    return to;\n  }\n}\n", "import { HashMD, Chi, Maj } from './_md.js';\nimport { rotr, wrapConstructor } from './utils.js';\n\n// SHA2-256 need to try 2^128 hashes to execute birthday attack.\n// BTC network is doing 2^67 hashes/sec as per early 2023.\n\n// Round constants:\n// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */ new Uint32Array([\n  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n\n// Initial state:\n// first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19\n// prettier-ignore\nconst SHA256_IV = /* @__PURE__ */ new Uint32Array([\n  0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n]);\n\n// Temporary buffer, not used to store anything between runs\n// Named this way because it matches specification.\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nexport class SHA256 extends HashMD<SHA256> {\n  // We cannot use array here since array allows indexing by variable\n  // which means optimizer/compiler cannot use registers.\n  A = SHA256_IV[0] | 0;\n  B = SHA256_IV[1] | 0;\n  C = SHA256_IV[2] | 0;\n  D = SHA256_IV[3] | 0;\n  E = SHA256_IV[4] | 0;\n  F = SHA256_IV[5] | 0;\n  G = SHA256_IV[6] | 0;\n  H = SHA256_IV[7] | 0;\n\n  constructor() {\n    super(64, 32, 8, false);\n  }\n  protected get(): [number, number, number, number, number, number, number, number] {\n    const { A, B, C, D, E, F, G, H } = this;\n    return [A, B, C, D, E, F, G, H];\n  }\n  // prettier-ignore\n  protected set(\n    A: number, B: number, C: number, D: number, E: number, F: number, G: number, H: number\n  ) {\n    this.A = A | 0;\n    this.B = B | 0;\n    this.C = C | 0;\n    this.D = D | 0;\n    this.E = E | 0;\n    this.F = F | 0;\n    this.G = G | 0;\n    this.H = H | 0;\n  }\n  protected process(view: DataView, offset: number): void {\n    // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n    for (let i = 0; i < 16; i++, offset += 4) SHA256_W[i] = view.getUint32(offset, false);\n    for (let i = 16; i < 64; i++) {\n      const W15 = SHA256_W[i - 15];\n      const W2 = SHA256_W[i - 2];\n      const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ (W15 >>> 3);\n      const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ (W2 >>> 10);\n      SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n    }\n    // Compression function main loop, 64 rounds\n    let { A, B, C, D, E, F, G, H } = this;\n    for (let i = 0; i < 64; i++) {\n      const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);\n      const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n      const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);\n      const T2 = (sigma0 + Maj(A, B, C)) | 0;\n      H = G;\n      G = F;\n      F = E;\n      E = (D + T1) | 0;\n      D = C;\n      C = B;\n      B = A;\n      A = (T1 + T2) | 0;\n    }\n    // Add the compressed chunk to the current hash value\n    A = (A + this.A) | 0;\n    B = (B + this.B) | 0;\n    C = (C + this.C) | 0;\n    D = (D + this.D) | 0;\n    E = (E + this.E) | 0;\n    F = (F + this.F) | 0;\n    G = (G + this.G) | 0;\n    H = (H + this.H) | 0;\n    this.set(A, B, C, D, E, F, G, H);\n  }\n  protected roundClean() {\n    SHA256_W.fill(0);\n  }\n  destroy() {\n    this.set(0, 0, 0, 0, 0, 0, 0, 0);\n    this.buffer.fill(0);\n  }\n}\n// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf\nclass SHA224 extends SHA256 {\n  A = 0xc1059ed8 | 0;\n  B = 0x367cd507 | 0;\n  C = 0x3070dd17 | 0;\n  D = 0xf70e5939 | 0;\n  E = 0xffc00b31 | 0;\n  F = 0x68581511 | 0;\n  G = 0x64f98fa7 | 0;\n  H = 0xbefa4fa4 | 0;\n  constructor() {\n    super();\n    this.outputLen = 28;\n  }\n}\n\n/**\n * SHA2-256 hash function\n * @param message - data that would be hashed\n */\nexport const sha256 = /* @__PURE__ */ wrapConstructor(() => new SHA256());\n/**\n * SHA2-224 hash function\n */\nexport const sha224 = /* @__PURE__ */ wrapConstructor(() => new SHA224());\n", "/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n// Utilities\n/**\n * @__NO_SIDE_EFFECTS__\n */\nexport function assertNumber(n: number) {\n  if (!Number.isSafeInteger(n)) throw new Error(`Wrong integer: ${n}`);\n}\nexport interface Coder<F, T> {\n  encode(from: F): T;\n  decode(to: T): F;\n}\n\nexport interface BytesCoder extends Coder<Uint8Array, string> {\n  encode: (data: Uint8Array) => string;\n  decode: (str: string) => Uint8Array;\n}\n\nfunction isBytes(a: unknown): a is Uint8Array {\n  return (\n    a instanceof Uint8Array ||\n    (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array')\n  );\n}\n\n// TODO: some recusive type inference so it would check correct order of input/output inside rest?\n// like <string, number>, <number, bytes>, <bytes, float>\ntype Chain = [Coder<any, any>, ...Coder<any, any>[]];\n// Extract info from Coder type\ntype Input<F> = F extends Coder<infer T, any> ? T : never;\ntype Output<F> = F extends Coder<any, infer T> ? T : never;\n// Generic function for arrays\ntype First<T> = T extends [infer U, ...any[]] ? U : never;\ntype Last<T> = T extends [...any[], infer U] ? U : never;\ntype Tail<T> = T extends [any, ...infer U] ? U : never;\n\ntype AsChain<C extends Chain, Rest = Tail<C>> = {\n  // C[K] = Coder<Input<C[K]>, Input<Rest[k]>>\n  [K in keyof C]: Coder<Input<C[K]>, Input<K extends keyof Rest ? Rest[K] : any>>;\n};\n\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction chain<T extends Chain & AsChain<T>>(...args: T): Coder<Input<First<T>>, Output<Last<T>>> {\n  const id = (a: any) => a;\n  // Wrap call in closure so JIT can inline calls\n  const wrap = (a: any, b: any) => (c: any) => a(b(c));\n  // Construct chain of args[-1].encode(args[-2].encode([...]))\n  const encode = args.map((x) => x.encode).reduceRight(wrap, id);\n  // Construct chain of args[0].decode(args[1].decode(...))\n  const decode = args.map((x) => x.decode).reduce(wrap, id);\n  return { encode, decode };\n}\n\ntype Alphabet = string[] | string;\n\n/**\n * Encodes integer radix representation to array of strings using alphabet and back\n * @__NO_SIDE_EFFECTS__\n */\nfunction alphabet(alphabet: Alphabet): Coder<number[], string[]> {\n  return {\n    encode: (digits: number[]) => {\n      if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))\n        throw new Error('alphabet.encode input should be an array of numbers');\n      return digits.map((i) => {\n        assertNumber(i);\n        if (i < 0 || i >= alphabet.length)\n          throw new Error(`Digit index outside alphabet: ${i} (alphabet: ${alphabet.length})`);\n        return alphabet[i]!;\n      });\n    },\n    decode: (input: string[]) => {\n      if (!Array.isArray(input) || (input.length && typeof input[0] !== 'string'))\n        throw new Error('alphabet.decode input should be array of strings');\n      return input.map((letter) => {\n        if (typeof letter !== 'string')\n          throw new Error(`alphabet.decode: not string element=${letter}`);\n        const index = alphabet.indexOf(letter);\n        if (index === -1) throw new Error(`Unknown letter: \"${letter}\". Allowed: ${alphabet}`);\n        return index;\n      });\n    },\n  };\n}\n\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction join(separator = ''): Coder<string[], string> {\n  if (typeof separator !== 'string') throw new Error('join separator should be string');\n  return {\n    encode: (from) => {\n      if (!Array.isArray(from) || (from.length && typeof from[0] !== 'string'))\n        throw new Error('join.encode input should be array of strings');\n      for (let i of from)\n        if (typeof i !== 'string') throw new Error(`join.encode: non-string input=${i}`);\n      return from.join(separator);\n    },\n    decode: (to) => {\n      if (typeof to !== 'string') throw new Error('join.decode input should be string');\n      return to.split(separator);\n    },\n  };\n}\n\n/**\n * Pad strings array so it has integer number of bits\n * @__NO_SIDE_EFFECTS__\n */\nfunction padding(bits: number, chr = '='): Coder<string[], string[]> {\n  assertNumber(bits);\n  if (typeof chr !== 'string') throw new Error('padding chr should be string');\n  return {\n    encode(data: string[]): string[] {\n      if (!Array.isArray(data) || (data.length && typeof data[0] !== 'string'))\n        throw new Error('padding.encode input should be array of strings');\n      for (let i of data)\n        if (typeof i !== 'string') throw new Error(`padding.encode: non-string input=${i}`);\n      while ((data.length * bits) % 8) data.push(chr);\n      return data;\n    },\n    decode(input: string[]): string[] {\n      if (!Array.isArray(input) || (input.length && typeof input[0] !== 'string'))\n        throw new Error('padding.encode input should be array of strings');\n      for (let i of input)\n        if (typeof i !== 'string') throw new Error(`padding.decode: non-string input=${i}`);\n      let end = input.length;\n      if ((end * bits) % 8)\n        throw new Error('Invalid padding: string should have whole number of bytes');\n      for (; end > 0 && input[end - 1] === chr; end--) {\n        if (!(((end - 1) * bits) % 8))\n          throw new Error('Invalid padding: string has too much padding');\n      }\n      return input.slice(0, end);\n    },\n  };\n}\n\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction normalize<T>(fn: (val: T) => T): Coder<T, T> {\n  if (typeof fn !== 'function') throw new Error('normalize fn should be function');\n  return { encode: (from: T) => from, decode: (to: T) => fn(to) };\n}\n\n/**\n * Slow: O(n^2) time complexity\n * @__NO_SIDE_EFFECTS__\n */\nfunction convertRadix(data: number[], from: number, to: number): number[] {\n  // base 1 is impossible\n  if (from < 2) throw new Error(`convertRadix: wrong from=${from}, base cannot be less than 2`);\n  if (to < 2) throw new Error(`convertRadix: wrong to=${to}, base cannot be less than 2`);\n  if (!Array.isArray(data)) throw new Error('convertRadix: data should be array');\n  if (!data.length) return [];\n  let pos = 0;\n  const res = [];\n  const digits = Array.from(data);\n  digits.forEach((d) => {\n    assertNumber(d);\n    if (d < 0 || d >= from) throw new Error(`Wrong integer: ${d}`);\n  });\n  while (true) {\n    let carry = 0;\n    let done = true;\n    for (let i = pos; i < digits.length; i++) {\n      const digit = digits[i]!;\n      const digitBase = from * carry + digit;\n      if (\n        !Number.isSafeInteger(digitBase) ||\n        (from * carry) / from !== carry ||\n        digitBase - digit !== from * carry\n      ) {\n        throw new Error('convertRadix: carry overflow');\n      }\n      carry = digitBase % to;\n      const rounded = Math.floor(digitBase / to);\n      digits[i] = rounded;\n      if (!Number.isSafeInteger(rounded) || rounded * to + carry !== digitBase)\n        throw new Error('convertRadix: carry overflow');\n      if (!done) continue;\n      else if (!rounded) pos = i;\n      else done = false;\n    }\n    res.push(carry);\n    if (done) break;\n  }\n  for (let i = 0; i < data.length - 1 && data[i] === 0; i++) res.push(0);\n  return res.reverse();\n}\n\nconst gcd = /* @__NO_SIDE_EFFECTS__ */ (a: number, b: number): number => (!b ? a : gcd(b, a % b));\nconst radix2carry = /*@__NO_SIDE_EFFECTS__ */ (from: number, to: number) =>\n  from + (to - gcd(from, to));\n/**\n * Implemented with numbers, because BigInt is 5x slower\n * @__NO_SIDE_EFFECTS__\n */\nfunction convertRadix2(data: number[], from: number, to: number, padding: boolean): number[] {\n  if (!Array.isArray(data)) throw new Error('convertRadix2: data should be array');\n  if (from <= 0 || from > 32) throw new Error(`convertRadix2: wrong from=${from}`);\n  if (to <= 0 || to > 32) throw new Error(`convertRadix2: wrong to=${to}`);\n  if (radix2carry(from, to) > 32) {\n    throw new Error(\n      `convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry(from, to)}`\n    );\n  }\n  let carry = 0;\n  let pos = 0; // bitwise position in current element\n  const mask = 2 ** to - 1;\n  const res: number[] = [];\n  for (const n of data) {\n    assertNumber(n);\n    if (n >= 2 ** from) throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);\n    carry = (carry << from) | n;\n    if (pos + from > 32) throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);\n    pos += from;\n    for (; pos >= to; pos -= to) res.push(((carry >> (pos - to)) & mask) >>> 0);\n    carry &= 2 ** pos - 1; // clean carry, otherwise it will cause overflow\n  }\n  carry = (carry << (to - pos)) & mask;\n  if (!padding && pos >= from) throw new Error('Excess padding');\n  if (!padding && carry) throw new Error(`Non-zero padding: ${carry}`);\n  if (padding && pos > 0) res.push(carry >>> 0);\n  return res;\n}\n\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction radix(num: number): Coder<Uint8Array, number[]> {\n  assertNumber(num);\n  return {\n    encode: (bytes: Uint8Array) => {\n      if (!isBytes(bytes)) throw new Error('radix.encode input should be Uint8Array');\n      return convertRadix(Array.from(bytes), 2 ** 8, num);\n    },\n    decode: (digits: number[]) => {\n      if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))\n        throw new Error('radix.decode input should be array of numbers');\n      return Uint8Array.from(convertRadix(digits, num, 2 ** 8));\n    },\n  };\n}\n\n/**\n * If both bases are power of same number (like `2**8 <-> 2**64`),\n * there is a linear algorithm. For now we have implementation for power-of-two bases only.\n * @__NO_SIDE_EFFECTS__\n */\nfunction radix2(bits: number, revPadding = false): Coder<Uint8Array, number[]> {\n  assertNumber(bits);\n  if (bits <= 0 || bits > 32) throw new Error('radix2: bits should be in (0..32]');\n  if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32)\n    throw new Error('radix2: carry overflow');\n  return {\n    encode: (bytes: Uint8Array) => {\n      if (!isBytes(bytes)) throw new Error('radix2.encode input should be Uint8Array');\n      return convertRadix2(Array.from(bytes), 8, bits, !revPadding);\n    },\n    decode: (digits: number[]) => {\n      if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))\n        throw new Error('radix2.decode input should be array of numbers');\n      return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));\n    },\n  };\n}\n\ntype ArgumentTypes<F extends Function> = F extends (...args: infer A) => any ? A : never;\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction unsafeWrapper<T extends (...args: any) => any>(fn: T) {\n  if (typeof fn !== 'function') throw new Error('unsafeWrapper fn should be function');\n  return function (...args: ArgumentTypes<T>): ReturnType<T> | void {\n    try {\n      return fn.apply(null, args);\n    } catch (e) {}\n  };\n}\n\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction checksum(\n  len: number,\n  fn: (data: Uint8Array) => Uint8Array\n): Coder<Uint8Array, Uint8Array> {\n  assertNumber(len);\n  if (typeof fn !== 'function') throw new Error('checksum fn should be function');\n  return {\n    encode(data: Uint8Array) {\n      if (!isBytes(data)) throw new Error('checksum.encode: input should be Uint8Array');\n      const checksum = fn(data).slice(0, len);\n      const res = new Uint8Array(data.length + len);\n      res.set(data);\n      res.set(checksum, data.length);\n      return res;\n    },\n    decode(data: Uint8Array) {\n      if (!isBytes(data)) throw new Error('checksum.decode: input should be Uint8Array');\n      const payload = data.slice(0, -len);\n      const newChecksum = fn(payload).slice(0, len);\n      const oldChecksum = data.slice(-len);\n      for (let i = 0; i < len; i++)\n        if (newChecksum[i] !== oldChecksum[i]) throw new Error('Invalid checksum');\n      return payload;\n    },\n  };\n}\n\n// prettier-ignore\nexport const utils = {\n  alphabet, chain, checksum, convertRadix, convertRadix2, radix, radix2, join, padding,\n};\n\n// RFC 4648 aka RFC 3548\n// ---------------------\nexport const base16: BytesCoder = /* @__PURE__ */ chain(\n  radix2(4),\n  alphabet('0123456789ABCDEF'),\n  join('')\n);\nexport const base32: BytesCoder = /* @__PURE__ */ chain(\n  radix2(5),\n  alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'),\n  padding(5),\n  join('')\n);\nexport const base32nopad: BytesCoder = /* @__PURE__ */ chain(\n  radix2(5),\n  alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'),\n  join('')\n);\nexport const base32hex: BytesCoder = /* @__PURE__ */ chain(\n  radix2(5),\n  alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'),\n  padding(5),\n  join('')\n);\nexport const base32hexnopad: BytesCoder = /* @__PURE__ */ chain(\n  radix2(5),\n  alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'),\n  join('')\n);\nexport const base32crockford: BytesCoder = /* @__PURE__ */ chain(\n  radix2(5),\n  alphabet('0123456789ABCDEFGHJKMNPQRSTVWXYZ'),\n  join(''),\n  normalize((s: string) => s.toUpperCase().replace(/O/g, '0').replace(/[IL]/g, '1'))\n);\nexport const base64: BytesCoder = /* @__PURE__ */ chain(\n  radix2(6),\n  alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'),\n  padding(6),\n  join('')\n);\nexport const base64nopad: BytesCoder = /* @__PURE__ */ chain(\n  radix2(6),\n  alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'),\n  join('')\n);\nexport const base64url: BytesCoder = /* @__PURE__ */ chain(\n  radix2(6),\n  alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'),\n  padding(6),\n  join('')\n);\nexport const base64urlnopad: BytesCoder = /* @__PURE__ */ chain(\n  radix2(6),\n  alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'),\n  join('')\n);\n\n// base58 code\n// -----------\nconst genBase58 = (abc: string) => chain(radix(58), alphabet(abc), join(''));\n\nexport const base58: BytesCoder = /* @__PURE__ */ genBase58(\n  '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n);\nexport const base58flickr: BytesCoder = /* @__PURE__ */ genBase58(\n  '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'\n);\nexport const base58xrp: BytesCoder = /* @__PURE__ */ genBase58(\n  'rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz'\n);\n\n// xmr ver is done in 8-byte blocks (which equals 11 chars in decoding). Last (non-full) block padded with '1' to size in XMR_BLOCK_LEN.\n// Block encoding significantly reduces quadratic complexity of base58.\n\n// Data len (index) -> encoded block len\nconst XMR_BLOCK_LEN = [0, 2, 3, 5, 6, 7, 9, 10, 11];\nexport const base58xmr: BytesCoder = {\n  encode(data: Uint8Array) {\n    let res = '';\n    for (let i = 0; i < data.length; i += 8) {\n      const block = data.subarray(i, i + 8);\n      res += base58.encode(block).padStart(XMR_BLOCK_LEN[block.length]!, '1');\n    }\n    return res;\n  },\n  decode(str: string) {\n    let res: number[] = [];\n    for (let i = 0; i < str.length; i += 11) {\n      const slice = str.slice(i, i + 11);\n      const blockLen = XMR_BLOCK_LEN.indexOf(slice.length);\n      const block = base58.decode(slice);\n      for (let j = 0; j < block.length - blockLen; j++) {\n        if (block[j] !== 0) throw new Error('base58xmr: wrong padding');\n      }\n      res = res.concat(Array.from(block.slice(block.length - blockLen)));\n    }\n    return Uint8Array.from(res);\n  },\n};\n\nexport const createBase58check = (sha256: (data: Uint8Array) => Uint8Array): BytesCoder =>\n  chain(\n    checksum(4, (data) => sha256(sha256(data))),\n    base58\n  );\n// legacy export, bad name\nexport const base58check = createBase58check;\n\n// Bech32 code\n// -----------\nexport interface Bech32Decoded<Prefix extends string = string> {\n  prefix: Prefix;\n  words: number[];\n}\nexport interface Bech32DecodedWithArray<Prefix extends string = string> {\n  prefix: Prefix;\n  words: number[];\n  bytes: Uint8Array;\n}\n\nconst BECH_ALPHABET: Coder<number[], string> = /* @__PURE__ */ chain(\n  alphabet('qpzry9x8gf2tvdw0s3jn54khce6mua7l'),\n  join('')\n);\n\nconst POLYMOD_GENERATORS = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction bech32Polymod(pre: number): number {\n  const b = pre >> 25;\n  let chk = (pre & 0x1ffffff) << 5;\n  for (let i = 0; i < POLYMOD_GENERATORS.length; i++) {\n    if (((b >> i) & 1) === 1) chk ^= POLYMOD_GENERATORS[i]!;\n  }\n  return chk;\n}\n\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction bechChecksum(prefix: string, words: number[], encodingConst = 1): string {\n  const len = prefix.length;\n  let chk = 1;\n  for (let i = 0; i < len; i++) {\n    const c = prefix.charCodeAt(i);\n    if (c < 33 || c > 126) throw new Error(`Invalid prefix (${prefix})`);\n    chk = bech32Polymod(chk) ^ (c >> 5);\n  }\n  chk = bech32Polymod(chk);\n  for (let i = 0; i < len; i++) chk = bech32Polymod(chk) ^ (prefix.charCodeAt(i) & 0x1f);\n  for (let v of words) chk = bech32Polymod(chk) ^ v;\n  for (let i = 0; i < 6; i++) chk = bech32Polymod(chk);\n  chk ^= encodingConst;\n  return BECH_ALPHABET.encode(convertRadix2([chk % 2 ** 30], 30, 5, false));\n}\n\nexport interface Bech32 {\n  encode<Prefix extends string>(\n    prefix: Prefix,\n    words: number[] | Uint8Array,\n    limit: number | false\n  ): `${Lowercase<Prefix>}1${string}`;\n  decode<Prefix extends string>(\n    str: `${Prefix}1${string}`,\n    limit?: number | false\n  ): Bech32Decoded<Prefix>;\n  decodeToBytes(str: string): Bech32DecodedWithArray;\n  decodeUnsafe(str: string, limit?: number | false): void | Bech32Decoded<string>;\n  fromWords(to: number[]): Uint8Array;\n  fromWordsUnsafe(to: number[]): void | Uint8Array;\n  toWords(from: Uint8Array): number[];\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction genBech32(encoding: 'bech32' | 'bech32m'): Bech32 {\n  const ENCODING_CONST = encoding === 'bech32' ? 1 : 0x2bc830a3;\n  const _words = radix2(5);\n  const fromWords = _words.decode;\n  const toWords = _words.encode;\n  const fromWordsUnsafe = unsafeWrapper(fromWords);\n\n  function encode<Prefix extends string>(\n    prefix: Prefix,\n    words: number[] | Uint8Array,\n    limit: number | false = 90\n  ): `${Lowercase<Prefix>}1${string}` {\n    if (typeof prefix !== 'string')\n      throw new Error(`bech32.encode prefix should be string, not ${typeof prefix}`);\n    if (!Array.isArray(words) || (words.length && typeof words[0] !== 'number'))\n      throw new Error(`bech32.encode words should be array of numbers, not ${typeof words}`);\n    if (prefix.length === 0) throw new TypeError(`Invalid prefix length ${prefix.length}`);\n    const actualLength = prefix.length + 7 + words.length;\n    if (limit !== false && actualLength > limit)\n      throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);\n    const lowered = prefix.toLowerCase();\n    const sum = bechChecksum(lowered, words, ENCODING_CONST);\n    return `${lowered}1${BECH_ALPHABET.encode(words)}${sum}` as `${Lowercase<Prefix>}1${string}`;\n  }\n\n  function decode<Prefix extends string>(\n    str: `${Prefix}1${string}`,\n    limit?: number | false\n  ): Bech32Decoded<Prefix>;\n  function decode(str: string, limit?: number | false): Bech32Decoded;\n  function decode(str: string, limit: number | false = 90): Bech32Decoded {\n    if (typeof str !== 'string')\n      throw new Error(`bech32.decode input should be string, not ${typeof str}`);\n    if (str.length < 8 || (limit !== false && str.length > limit))\n      throw new TypeError(`Wrong string length: ${str.length} (${str}). Expected (8..${limit})`);\n    // don't allow mixed case\n    const lowered = str.toLowerCase();\n    if (str !== lowered && str !== str.toUpperCase())\n      throw new Error(`String must be lowercase or uppercase`);\n    const sepIndex = lowered.lastIndexOf('1');\n    if (sepIndex === 0 || sepIndex === -1)\n      throw new Error(`Letter \"1\" must be present between prefix and data only`);\n    const prefix = lowered.slice(0, sepIndex);\n    const data = lowered.slice(sepIndex + 1);\n    if (data.length < 6) throw new Error('Data must be at least 6 characters long');\n    const words = BECH_ALPHABET.decode(data).slice(0, -6);\n    const sum = bechChecksum(prefix, words, ENCODING_CONST);\n    if (!data.endsWith(sum)) throw new Error(`Invalid checksum in ${str}: expected \"${sum}\"`);\n    return { prefix, words };\n  }\n\n  const decodeUnsafe = unsafeWrapper(decode);\n\n  function decodeToBytes(str: string): Bech32DecodedWithArray {\n    const { prefix, words } = decode(str, false);\n    return { prefix, words, bytes: fromWords(words) };\n  }\n\n  return { encode, decode, decodeToBytes, decodeUnsafe, fromWords, fromWordsUnsafe, toWords };\n}\n\nexport const bech32: Bech32 = /* @__PURE__ */ genBech32('bech32');\nexport const bech32m: Bech32 = /* @__PURE__ */ genBech32('bech32m');\n\ndeclare const TextEncoder: any;\ndeclare const TextDecoder: any;\n\nexport const utf8: BytesCoder = {\n  encode: (data) => new TextDecoder().decode(data),\n  decode: (str) => new TextEncoder().encode(str),\n};\n\nexport const hex: BytesCoder = /* @__PURE__ */ chain(\n  radix2(4),\n  alphabet('0123456789abcdef'),\n  join(''),\n  normalize((s: string) => {\n    if (typeof s !== 'string' || s.length % 2)\n      throw new TypeError(`hex.decode: expected string, got ${typeof s} with length ${s.length}`);\n    return s.toLowerCase();\n  })\n);\n\n// prettier-ignore\nconst CODERS = {\n  utf8, hex, base16, base32, base64, base64url, base58, base58xmr\n};\ntype CoderType = keyof typeof CODERS;\nconst coderTypeError =\n  'Invalid encoding type. Available types: utf8, hex, base16, base32, base64, base64url, base58, base58xmr';\n\nexport const bytesToString = (type: CoderType, bytes: Uint8Array): string => {\n  if (typeof type !== 'string' || !CODERS.hasOwnProperty(type)) throw new TypeError(coderTypeError);\n  if (!isBytes(bytes)) throw new TypeError('bytesToString() expects Uint8Array');\n  return CODERS[type].encode(bytes);\n};\nexport const str = bytesToString; // as in python, but for bytes only\n\nexport const stringToBytes = (type: CoderType, str: string): Uint8Array => {\n  if (!CODERS.hasOwnProperty(type)) throw new TypeError(coderTypeError);\n  if (typeof str !== 'string') throw new TypeError('stringToBytes() expects string');\n  return CODERS[type].decode(str);\n};\nexport const bytes = stringToBytes;\n", "{\n    \"actions\": [\n        {\n            \"id\": 0,\n            \"name\": \"ABI\"\n        }\n    ],\n    \"outputs\": [],\n    \"types\": [\n        {\n            \"name\": \"ABI\",\n            \"fields\": [\n                {\n                    \"name\": \"actions\",\n                    \"type\": \"[]TypedStruct\"\n                },\n                {\n                    \"name\": \"outputs\",\n                    \"type\": \"[]TypedStruct\"\n                },\n                {\n                    \"name\": \"types\",\n                    \"type\": \"[]Type\"\n                }\n            ]\n        },\n        {\n            \"name\": \"TypedStruct\",\n            \"fields\": [\n                {\n                    \"name\": \"id\",\n                    \"type\": \"uint8\"\n                },\n                {\n                    \"name\": \"name\",\n                    \"type\": \"string\"\n                }\n            ]\n        },\n        {\n            \"name\": \"Type\",\n            \"fields\": [\n                {\n                    \"name\": \"name\",\n                    \"type\": \"string\"\n                },\n                {\n                    \"name\": \"fields\",\n                    \"type\": \"[]Field\"\n                }\n            ]\n        },\n        {\n            \"name\": \"Field\",\n            \"fields\": [\n                {\n                    \"name\": \"name\",\n                    \"type\": \"string\"\n                },\n                {\n                    \"name\": \"type\",\n                    \"type\": \"string\"\n                }\n            ]\n        }\n    ]\n}\n", "import { sha256 } from '@noble/hashes/sha256';\nimport { parse } from 'lossless-json'\nimport { base64 } from '@scure/base';\nimport ABIsABI from './testdata/abi.abi.json'\nimport { bytesToHex, hexToBytes } from '@noble/hashes/utils';\nimport { ActionData, TransactionPayload } from './types';\n\nexport const ED25519_AUTH_ID = 0x00\n\nexport type VMABI = {\n    actions: TypedStructABI[]\n    outputs: TypedStructABI[]\n    types: TypeABI[]\n}\n\ntype TypedStructABI = {\n    id: number\n    name: string\n}\n\ntype TypeABI = {\n    name: string,\n    fields: ABIField[]\n}\n\ntype ABIField = {\n    name: string,\n    type: string\n}\n\nexport class Marshaler {\n    constructor(private abi: VMABI) {\n        if (!Array.isArray(this.abi?.actions) || !Array.isArray(this.abi?.outputs)) {\n            throw new Error('Invalid ABI')\n        }\n    }\n\n    public getHash(): Uint8Array {\n        const abiAbiMarshaler = new Marshaler(ABIsABI)\n        const abiBytes = abiAbiMarshaler.encode(\"ABI\", JSON.stringify(this.abi))\n        return sha256(abiBytes)\n    }\n\n    public encode(typeName: string, dataJSON: string): Uint8Array {\n        const data = parse(dataJSON) as Record<string, unknown>;\n        return this.encodeField(typeName, data);\n    }\n\n    public encodeTyped(typeName: string, dataJSON: string): Uint8Array {\n        const data = parse(dataJSON) as Record<string, unknown>\n        const typeABI = this.abi.types.find(type => type.name === typeName)\n\n        if (!typeABI) {\n            throw new Error(`Type ${typeName} not found in ABI`)\n        }\n\n        // Check for extra fields\n        const extraFields = Object.keys(data).filter(key => !typeABI.fields.some(field => field.name === key))\n        if (extraFields.length > 0) {\n            throw new Error(`Extra fields found in data: ${extraFields.join(', ')}`)\n        }\n\n        const typeId = [...this.abi.actions, ...this.abi.outputs].find(typ => typ.name === typeName)?.id\n\n        if (typeId === undefined) {\n            throw new Error(`Type ID not found for ${typeName}`)\n        }\n\n        const encodedData = this.encodeField(typeName, data)\n        return new Uint8Array([typeId, ...encodedData])\n    }\n\n    public parseTyped(binary: Uint8Array, typeCategory: 'action' | 'output'): [Record<string, unknown>, number] {\n        if (binary.length === 0) {\n            throw new Error('Empty binary data')\n        }\n\n        const typeId = binary[0]\n        const data = binary.slice(1)\n\n        const typeList = typeCategory === 'action' ? this.abi.actions : this.abi.outputs\n        const foundType = typeList.find(typ => typ.id === typeId)\n\n        if (!foundType) {\n            console.log(typeList)\n            throw new Error(`No ${typeCategory} found for id ${typeId}`)\n        }\n\n        return this.parse(foundType.name, data) as [Record<string, unknown>, number]\n    }\n\n    public parse(outputType: string, actionResultBinary: Uint8Array): [Record<string, unknown>, number] {\n        // Handle primitive types\n        if (isPrimitiveType(outputType)) {\n            return this.decodeField(outputType, actionResultBinary);\n        }\n\n        // Handle struct types\n        let structABI = this.abi.types.find((type) => type.name === outputType);\n        if (!structABI) {\n            throw new Error(`No struct ABI found for type ${outputType}`);\n        }\n\n        let result: Record<string, unknown> = {};\n        let offset = 0;\n\n        for (const field of structABI.fields) {\n            const fieldType = field.type;\n\n            // Decode field based on type\n            const [decodedValue, bytesConsumed] = this.decodeField(fieldType, actionResultBinary.subarray(offset));\n            result[field.name] = decodedValue;\n            offset += bytesConsumed;\n        }\n\n        return [result, offset];\n    }\n\n    public decodeField<T>(type: string, binaryData: Uint8Array): [T, number] {\n        // Decodes field and returns value and the number of bytes consumed.\n        switch (type) {\n            case \"bool\":\n                return decodeBool(binaryData) as [T, number]\n            case \"[]uint8\":\n                return decodeBytes(binaryData) as [T, number]\n            case \"uint8\":\n            case \"uint16\":\n            case \"uint32\":\n            case \"uint64\":\n            case \"uint256\":\n                return [decodeNumber(type, binaryData) as T, getByteSize(type)];\n            case \"string\":\n                return decodeString(binaryData) as [T, number]\n            case \"Address\":\n                return decodeAddress(binaryData) as [T, number]\n            case \"int8\":\n            case \"int16\":\n            case \"int32\":\n            case \"int64\":\n                return [decodeNumber(type, binaryData) as T, getByteSize(type)];\n            default:\n                // Handle arrays and structs\n                if (type.startsWith('[]')) {\n                    return this.decodeSlice(type.slice(2), binaryData) as [T, number]\n                } else if (type.startsWith('[')) {\n                    //parse [length]type\n                    const match = type.match(/^\\[(\\d+)\\](.+)$/);\n                    if (match && match[1] && match[2]) {\n                        const length = parseInt(match[1], 10);\n                        const elementType = match[2];\n                        return this.decodeArray(elementType, binaryData, length) as [T, number]\n                    } else {\n                        throw new Error(`Unsupported type: ${type}`);\n                    }\n                } else {\n                    // Struct type\n                    const [decodedStruct, _] = this.parse(type, binaryData);\n                    const bytesConsumed = this.getStructByteSize(type, binaryData);\n                    return [decodedStruct as T, bytesConsumed];\n                }\n        }\n    }\n\n    private decodeSlice(type: string, binaryData: Uint8Array): [unknown[], number] {\n        const length = decodeNumber(\"uint32\", binaryData) as number;\n        const [resultArray, offset] = this.decodeArray(type, binaryData.subarray(4), length);\n        return [resultArray, offset + 4]\n    }\n\n    private decodeArray(type: string, binaryData: Uint8Array, length: number): [unknown[], number] {\n        let offset = 0;\n        let resultArray = [];\n        for (let i = 0; i < length; i++) {\n            const [decodedValue, bytesConsumed] = this.decodeField(type, binaryData.subarray(offset));\n            resultArray.push(decodedValue);\n            offset += bytesConsumed;\n        }\n        return [resultArray, offset];\n    }\n\n    private getStructByteSize(type: string, binaryData: Uint8Array): number {\n        const structABI = this.abi.types.find((t) => t.name === type);\n        if (!structABI) {\n            throw new Error(`No struct ABI found for type ${type}`);\n        }\n\n        let totalSize = 0;\n        for (const field of structABI.fields) {\n            const [_, bytesConsumed] = this.decodeField(field.type, binaryData.subarray(totalSize));\n            totalSize += bytesConsumed;\n        }\n        return totalSize;\n    }\n\n    public encodeTransaction(tx: TransactionPayload): Uint8Array {\n        if (tx.base.timestamp.slice(-3) !== \"000\") {\n            tx.base.timestamp = String(Math.floor(parseInt(tx.base.timestamp) / 1000) * 1000)\n        }\n\n        const timestampBytes = encodeNumber(\"uint64\", tx.base.timestamp);\n        const chainIdBytes = encodeNumber(\"uint256\", tx.base.chainId);\n        const maxFeeBytes = encodeNumber(\"uint64\", tx.base.maxFee);\n        const actionsCountBytes = encodeNumber(\"uint8\", tx.actions.length);\n\n        let actionsBytes = new Uint8Array();\n        for (const action of tx.actions) {\n            const actionTypeIdBytes = encodeNumber(\"uint8\", this.getActionTypeId(action.actionName));\n            const actionDataBytes = this.encodeField(action.actionName, action.data);\n            actionsBytes = new Uint8Array([...actionsBytes, ...actionTypeIdBytes, ...actionDataBytes]);\n        }\n\n        // const abiHashBytes = this.getHash()\n\n        return new Uint8Array([\n            // ...abiHashBytes //TODO: add abi hash to the end of the signable body of transaction\n            ...timestampBytes,\n            ...chainIdBytes,\n            ...maxFeeBytes,\n            ...actionsCountBytes,\n            ...actionsBytes,\n        ]);\n    }\n\n    public decodeTransaction(tx: Uint8Array): [TransactionPayload, number] {\n        let offset = 0\n        let timestamp: bigint\n        let bytesConsumed: number\n\n        [timestamp, bytesConsumed] = this.decodeField<bigint>(\"uint64\", tx.slice(offset))\n        offset += bytesConsumed\n\n        let chainIdBase64: string\n        [chainIdBase64, bytesConsumed] = this.decodeField<string>(\"[32]uint8\", tx.slice(offset))\n        offset += bytesConsumed\n\n        let maxFee: bigint\n        [maxFee, bytesConsumed] = this.decodeField<bigint>(\"uint64\", tx.slice(offset))\n        offset += bytesConsumed\n\n        let actionsCount: number\n        [actionsCount, bytesConsumed] = this.decodeField<number>(\"uint8\", tx.slice(offset))\n        offset += bytesConsumed\n\n        let actions: ActionData[] = []\n        for (let i = 0; i < actionsCount; i++) {\n            const [action, bytesConsumed] = this.parseTyped(tx.slice(offset), \"action\")\n            actions.push(action as ActionData)\n            offset += bytesConsumed\n        }\n\n        return [{\n            base: {\n                timestamp: timestamp.toString(),\n                chainId: chainIdBase64,//FIXME: might be a mistake here\n                maxFee: maxFee.toString(),\n            },\n            actions\n        }, offset]\n    }\n\n    public getActionTypeId(actionName: string): number {\n        const actionABI = this.abi.actions.find(action => action.name === actionName)\n        if (!actionABI) throw new Error(`No action ABI found: ${actionName}`)\n        return actionABI.id\n    }\n\n    private encodeField(type: string, value: unknown, parentActionName?: string): Uint8Array {\n        if (type === 'Address' && typeof value === 'string') {\n            return encodeAddress(value)\n        }\n\n        if ((type === '[]uint8') && typeof value === 'string') {\n            const byteArray = Array.from(atob(value), char => char.charCodeAt(0)) as number[]\n            return new Uint8Array([...encodeNumber(\"uint32\", byteArray.length), ...byteArray])\n        }\n\n        if (type.startsWith('[]')) {\n            return this.encodeSlice(type.slice(2), value as unknown[]);\n        } else if (type.startsWith('[')) {\n            //parse [length]type\n            const match = type.match(/^\\[(\\d+)\\](.+)$/);\n            if (match && match[1] && match[2]) {\n                const length = parseInt(match[1], 10);\n                const elementType = match[2];\n                return this.encodeArray(elementType, value as unknown[], length);\n            } else {\n                throw new Error(`Unsupported type: ${type}`);\n            }\n        }\n\n        switch (type) {\n            case \"bool\":\n                return encodeBool(value as boolean)\n            case \"uint8\":\n            case \"uint16\":\n            case \"uint32\":\n            case \"uint64\":\n            case \"int8\":\n            case \"int16\":\n            case \"int32\":\n            case \"int64\":\n                return encodeNumber(type, value as number | string)\n            case \"string\":\n                return encodeString(value as string)\n            default:\n                {\n                    let structABI: TypeABI | null = null\n                    for (const typ of this.abi.types) {\n                        if (typ.name === type) {\n                            structABI = typ\n                            break\n                        }\n                    }\n                    if (!structABI) throw new Error(`No struct ${type} found in action ${type} ABI`)\n\n                    const dataRecord = value as Record<string, unknown>;\n                    let resultingBinary = new Uint8Array()\n                    for (const field of structABI.fields) {\n                        const fieldBinary = this.encodeField(field.type, dataRecord[field.name], type);\n                        resultingBinary = new Uint8Array([...resultingBinary, ...fieldBinary])\n                    }\n                    return resultingBinary\n                }\n        }\n    }\n\n    private encodeSlice(type: string, value: unknown[]): Uint8Array {\n        if (!Array.isArray(value)) {\n            throw new Error(`Error in encodeArray: Expected an array for type ${type}, but received ${typeof value} of declared type ${type}`)\n        }\n        const lengthBytes = encodeNumber(\"uint32\", value.length);\n        return new Uint8Array([...lengthBytes, ...this.encodeArray(type, value, value.length)]);\n    }\n\n    private encodeArray(type: string, value: unknown[], expectedLength: number): Uint8Array {\n        if (value.length !== expectedLength) {\n            throw new Error(`Error in encodeArray: Expected an array of length ${expectedLength} for type ${type}, but received an array of length ${value.length}`)\n        }\n        const encodedItems = value.map(item => this.encodeField(type, item));\n        const flattenedItems = encodedItems.reduce((acc, item) => {\n            if (item instanceof Uint8Array) {\n                return [...acc, ...item];\n            } else if (typeof item === 'number') {\n                return [...acc, item];\n            } else {\n                throw new Error(`Unexpected item type in encoded array: ${typeof item}`);\n            }\n        }, [] as number[]);\n        return new Uint8Array(flattenedItems)\n    }\n}\n\nfunction isPrimitiveType(type: string): boolean {\n    const primitiveTypes = [\n        \"uint8\", \"uint16\", \"uint32\", \"uint64\", \"uint256\",\n        \"int8\", \"int16\", \"int32\", \"int64\",\n        \"string\", \"Address\", \"[]uint8\"\n    ];\n    return primitiveTypes.includes(type) || type.startsWith('[]');\n}\n\nexport function decodeNumber(type: string, binaryData: Uint8Array): bigint | number {\n    const dataView = new DataView(binaryData.buffer, binaryData.byteOffset, binaryData.byteLength);\n    let result: bigint | number;\n\n    switch (type) {\n        case \"uint8\":\n            result = dataView.getUint8(0);\n            break;\n        case \"uint16\":\n            result = dataView.getUint16(0, false);\n            break;\n        case \"uint32\":\n            result = dataView.getUint32(0, false);\n            break;\n        case \"uint64\":\n            result = dataView.getBigUint64(0, false);\n            break;\n        case \"int8\":\n            result = dataView.getInt8(0);\n            break;\n        case \"int16\":\n            result = dataView.getInt16(0, false);\n            break;\n        case \"int32\":\n            result = dataView.getInt32(0, false);\n            break;\n        case \"int64\":\n            result = dataView.getBigInt64(0, false);\n            break;\n        default:\n            throw new Error(`Unsupported number type: ${type}`);\n    }\n\n    return result;\n}\n\nfunction getByteSize(type: string): number {\n    switch (type) {\n        case \"uint8\": return 1;\n        case \"uint16\": return 2;\n        case \"uint32\": return 4;\n        case \"uint64\": return 8;\n        case \"uint256\": return 32;\n        case \"int8\": return 1;\n        case \"int16\": return 2;\n        case \"int32\": return 4;\n        case \"int64\": return 8;\n        default: throw new Error(`Unknown type for byte size: ${type}`);\n    }\n}\n\nfunction decodeString(binaryData: Uint8Array): [string, number] {\n    const length = decodeNumber(\"uint16\", binaryData) as number;\n    const textDecoder = new TextDecoder();\n    const stringBytes = binaryData.subarray(2, 2 + length); // Skip the length bytes\n    const result: [string, number] = [textDecoder.decode(stringBytes), 2 + length];\n    return result\n}\n\nexport function decodeAddress(binaryData: Uint8Array): [string, number] {\n    if (binaryData.length < 33) {\n        throw new Error(\"Decoding address: has to have 33 bytes length\")\n    }\n    const addressBytes = binaryData.subarray(0, 33); // Fixed length for Address (33 bytes)\n    const hash = sha256(addressBytes);\n    const checksum = hash.slice(-4); // Take last 4 bytes\n    return [\"0x\" + bytesToHex(addressBytes) + bytesToHex(checksum), 33];\n}\n\nfunction decodeBytes(binaryData: Uint8Array): [string, number] {\n    const length = decodeNumber(\"uint32\", binaryData) as number;\n    const byteArray = binaryData.subarray(4, 4 + length); // Skip the length bytes\n    const base64String = base64.encode(byteArray);\n    return [base64String, 4 + length];\n}\n\nfunction encodeAddress(value: string): Uint8Array {\n    if (!/^0x[0-9a-fA-F]{74}$/.test(value)) {\n        throw new Error(`Address must be a 74-character hex string with '0x' prefix: ${value}`);\n    }\n\n    // Remove 0x prefix\n    const hexWithoutPrefix = value.slice(2);\n    const allBytes = hexToBytes(hexWithoutPrefix);\n\n    // Split into address and checksum\n    const addressBytes = allBytes.slice(0, 33);\n    const providedChecksum = allBytes.slice(33, 37);\n\n    // Calculate expected checksum\n    const hash = sha256(addressBytes);\n    const expectedChecksum = hash.slice(-4); // Take last 4 bytes\n\n    // Verify checksum\n    for (let i = 0; i < 4; i++) {\n        if (providedChecksum[i] !== expectedChecksum[i]) {\n            throw new Error('Invalid address checksum');\n        }\n    }\n\n    return addressBytes;\n}\n\nexport function addressBytesFromPubKey(pubKey: Uint8Array): Uint8Array {\n    return new Uint8Array([ED25519_AUTH_ID, ...sha256(pubKey)])\n}\n\nexport function addressHexFromPubKey(pubKey: Uint8Array): string {\n    const addressBytes = addressBytesFromPubKey(pubKey)\n    const hash = sha256(addressBytes)\n    const checksum = hash.slice(-4) // Take last 4 bytes\n    return \"0x\" + bytesToHex(addressBytes) + bytesToHex(checksum)\n}\n\nexport function encodeNumber(type: string, value: number | string): Uint8Array {\n    let bigValue = BigInt(value)\n    let buffer: ArrayBuffer\n    let dataView: DataView\n\n    switch (type) {\n        case \"uint8\":\n            buffer = new ArrayBuffer(1)\n            dataView = new DataView(buffer)\n            dataView.setUint8(0, Number(bigValue))\n            break\n        case \"uint16\":\n            buffer = new ArrayBuffer(2)\n            dataView = new DataView(buffer)\n            dataView.setUint16(0, Number(bigValue), false)\n            break\n        case \"uint32\":\n            buffer = new ArrayBuffer(4)\n            dataView = new DataView(buffer)\n            dataView.setUint32(0, Number(bigValue), false)\n            break\n        case \"uint64\":\n            buffer = new ArrayBuffer(8)\n            dataView = new DataView(buffer)\n            dataView.setBigUint64(0, bigValue, false)\n            break\n        case \"uint256\":\n            buffer = new ArrayBuffer(32)\n            dataView = new DataView(buffer)\n            for (let i = 0; i < 32; i++) {\n                dataView.setUint8(31 - i, Number(bigValue & 255n))\n                bigValue >>= 8n\n            }\n            break\n        case \"int8\":\n            buffer = new ArrayBuffer(1)\n            dataView = new DataView(buffer)\n            dataView.setInt8(0, Number(bigValue))\n            break\n        case \"int16\":\n            buffer = new ArrayBuffer(2)\n            dataView = new DataView(buffer)\n            dataView.setInt16(0, Number(bigValue), false)\n            break\n        case \"int32\":\n            buffer = new ArrayBuffer(4)\n            dataView = new DataView(buffer)\n            dataView.setInt32(0, Number(bigValue), false)\n            break\n        case \"int64\":\n            buffer = new ArrayBuffer(8)\n            dataView = new DataView(buffer)\n            dataView.setBigInt64(0, bigValue, false)\n            break\n        default:\n            throw new Error(`Unsupported number type: ${type}`)\n    }\n\n    return new Uint8Array(buffer)\n}\n\nfunction encodeString(value: string): Uint8Array {\n    const encoder = new TextEncoder()\n    const stringBytes = encoder.encode(value)\n    const lengthBytes = encodeNumber(\"uint16\", stringBytes.length)\n    return new Uint8Array([...lengthBytes, ...stringBytes])\n}\n\nfunction encodeBool(value: boolean): Uint8Array {\n    return new Uint8Array([value ? 1 : 0])\n}\n\nfunction decodeBool(binaryData: Uint8Array): [boolean, number] {\n    const val = binaryData[0];\n    if (val !== 0 && val !== 1) {\n        throw new Error(`Invalid boolean value: ${val}. Expected 0 or 1.`);\n    }\n    const value = val === 1;\n    return [value, 1];\n}\n"],
  "mappings": "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",
  "names": ["bytes", "hex", "isLE", "isBytes", "alphabet", "padding", "bytes", "bytesConsumed"]
}
