import {
  parse
} from "./chunk-NWNMAUAS.js";

// node_modules/hypersdk-client/node_modules/@noble/hashes/esm/_assert.js
function isBytes(a) {
  return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
}
function bytes(b, ...lengths) {
  if (!isBytes(b))
    throw new Error("Uint8Array expected");
  if (lengths.length > 0 && !lengths.includes(b.length))
    throw new Error(`Uint8Array expected of length ${lengths}, not of length=${b.length}`);
}
function exists(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function output(out, instance) {
  bytes(out);
  const min = instance.outputLen;
  if (out.length < min) {
    throw new Error(`digestInto() expects output buffer of length at least ${min}`);
  }
}

// node_modules/hypersdk-client/node_modules/@noble/hashes/esm/crypto.js
var crypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;

// node_modules/hypersdk-client/node_modules/@noble/hashes/esm/utils.js
var createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
var rotr = (word, shift) => word << 32 - shift | word >>> shift;
var isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
var hexes = Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
function bytesToHex(bytes2) {
  bytes(bytes2);
  let hex2 = "";
  for (let i = 0; i < bytes2.length; i++) {
    hex2 += hexes[bytes2[i]];
  }
  return hex2;
}
var asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
function asciiToBase16(char) {
  if (char >= asciis._0 && char <= asciis._9)
    return char - asciis._0;
  if (char >= asciis._A && char <= asciis._F)
    return char - (asciis._A - 10);
  if (char >= asciis._a && char <= asciis._f)
    return char - (asciis._a - 10);
  return;
}
function hexToBytes(hex2) {
  if (typeof hex2 !== "string")
    throw new Error("hex string expected, got " + typeof hex2);
  const hl = hex2.length;
  const al = hl / 2;
  if (hl % 2)
    throw new Error("padded hex string expected, got unpadded hex of length " + hl);
  const array = new Uint8Array(al);
  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
    const n1 = asciiToBase16(hex2.charCodeAt(hi));
    const n2 = asciiToBase16(hex2.charCodeAt(hi + 1));
    if (n1 === void 0 || n2 === void 0) {
      const char = hex2[hi] + hex2[hi + 1];
      throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
    }
    array[ai] = n1 * 16 + n2;
  }
  return array;
}
function utf8ToBytes(str) {
  if (typeof str !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes(data) {
  if (typeof data === "string")
    data = utf8ToBytes(data);
  bytes(data);
  return data;
}
function concatBytes(...arrays) {
  let sum = 0;
  for (let i = 0; i < arrays.length; i++) {
    const a = arrays[i];
    bytes(a);
    sum += a.length;
  }
  const res = new Uint8Array(sum);
  for (let i = 0, pad = 0; i < arrays.length; i++) {
    const a = arrays[i];
    res.set(a, pad);
    pad += a.length;
  }
  return res;
}
var Hash = class {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
var toStr = {}.toString;
function wrapConstructor(hashCons) {
  const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
  const tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashCons();
  return hashC;
}
function randomBytes(bytesLength = 32) {
  if (crypto && typeof crypto.getRandomValues === "function") {
    return crypto.getRandomValues(new Uint8Array(bytesLength));
  }
  if (crypto && typeof crypto.randomBytes === "function") {
    return crypto.randomBytes(bytesLength);
  }
  throw new Error("crypto.getRandomValues must be defined");
}

// node_modules/hypersdk-client/node_modules/@noble/hashes/esm/_md.js
function setBigUint64(view, byteOffset, value, isLE2) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value, isLE2);
  const _32n = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value >> _32n & _u32_max);
  const wl = Number(value & _u32_max);
  const h = isLE2 ? 4 : 0;
  const l = isLE2 ? 0 : 4;
  view.setUint32(byteOffset + h, wh, isLE2);
  view.setUint32(byteOffset + l, wl, isLE2);
}
var Chi = (a, b, c) => a & b ^ ~a & c;
var Maj = (a, b, c) => a & b ^ a & c ^ b & c;
var HashMD = class extends Hash {
  constructor(blockLen, outputLen, padOffset, isLE2) {
    super();
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE2;
    this.finished = false;
    this.length = 0;
    this.pos = 0;
    this.destroyed = false;
    this.buffer = new Uint8Array(blockLen);
    this.view = createView(this.buffer);
  }
  update(data) {
    exists(this);
    const { view, buffer, blockLen } = this;
    data = toBytes(data);
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      if (take === blockLen) {
        const dataView = createView(data);
        for (; blockLen <= len - pos; pos += blockLen)
          this.process(dataView, pos);
        continue;
      }
      buffer.set(data.subarray(pos, pos + take), this.pos);
      this.pos += take;
      pos += take;
      if (this.pos === blockLen) {
        this.process(view, 0);
        this.pos = 0;
      }
    }
    this.length += data.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    exists(this);
    output(out, this);
    this.finished = true;
    const { buffer, view, blockLen, isLE: isLE2 } = this;
    let { pos } = this;
    buffer[pos++] = 128;
    this.buffer.subarray(pos).fill(0);
    if (this.padOffset > blockLen - pos) {
      this.process(view, 0);
      pos = 0;
    }
    for (let i = pos; i < blockLen; i++)
      buffer[i] = 0;
    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE2);
    this.process(view, 0);
    const oview = createView(out);
    const len = this.outputLen;
    if (len % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const outLen = len / 4;
    const state = this.get();
    if (outLen > state.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let i = 0; i < outLen; i++)
      oview.setUint32(4 * i, state[i], isLE2);
  }
  digest() {
    const { buffer, outputLen } = this;
    this.digestInto(buffer);
    const res = buffer.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to) {
    to || (to = new this.constructor());
    to.set(...this.get());
    const { blockLen, buffer, length, finished, destroyed, pos } = this;
    to.length = length;
    to.pos = pos;
    to.finished = finished;
    to.destroyed = destroyed;
    if (length % blockLen)
      to.buffer.set(buffer);
    return to;
  }
};

// node_modules/hypersdk-client/node_modules/@noble/hashes/esm/sha256.js
var SHA256_K = new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
var SHA256_IV = new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
var SHA256_W = new Uint32Array(64);
var SHA256 = class extends HashMD {
  constructor() {
    super(64, 32, 8, false);
    this.A = SHA256_IV[0] | 0;
    this.B = SHA256_IV[1] | 0;
    this.C = SHA256_IV[2] | 0;
    this.D = SHA256_IV[3] | 0;
    this.E = SHA256_IV[4] | 0;
    this.F = SHA256_IV[5] | 0;
    this.G = SHA256_IV[6] | 0;
    this.H = SHA256_IV[7] | 0;
  }
  get() {
    const { A, B, C, D, E, F, G, H } = this;
    return [A, B, C, D, E, F, G, H];
  }
  // prettier-ignore
  set(A, B, C, D, E, F, G, H) {
    this.A = A | 0;
    this.B = B | 0;
    this.C = C | 0;
    this.D = D | 0;
    this.E = E | 0;
    this.F = F | 0;
    this.G = G | 0;
    this.H = H | 0;
  }
  process(view, offset) {
    for (let i = 0; i < 16; i++, offset += 4)
      SHA256_W[i] = view.getUint32(offset, false);
    for (let i = 16; i < 64; i++) {
      const W15 = SHA256_W[i - 15];
      const W2 = SHA256_W[i - 2];
      const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
      const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;
      SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
    }
    let { A, B, C, D, E, F, G, H } = this;
    for (let i = 0; i < 64; i++) {
      const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);
      const T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
      const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);
      const T2 = sigma0 + Maj(A, B, C) | 0;
      H = G;
      G = F;
      F = E;
      E = D + T1 | 0;
      D = C;
      C = B;
      B = A;
      A = T1 + T2 | 0;
    }
    A = A + this.A | 0;
    B = B + this.B | 0;
    C = C + this.C | 0;
    D = D + this.D | 0;
    E = E + this.E | 0;
    F = F + this.F | 0;
    G = G + this.G | 0;
    H = H + this.H | 0;
    this.set(A, B, C, D, E, F, G, H);
  }
  roundClean() {
    SHA256_W.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
    this.buffer.fill(0);
  }
};
var SHA224 = class extends SHA256 {
  constructor() {
    super();
    this.A = 3238371032 | 0;
    this.B = 914150663 | 0;
    this.C = 812702999 | 0;
    this.D = 4144912697 | 0;
    this.E = 4290775857 | 0;
    this.F = 1750603025 | 0;
    this.G = 1694076839 | 0;
    this.H = 3204075428 | 0;
    this.outputLen = 28;
  }
};
var sha256 = wrapConstructor(() => new SHA256());
var sha224 = wrapConstructor(() => new SHA224());

// node_modules/@scure/base/lib/esm/index.js
function assertNumber(n) {
  if (!Number.isSafeInteger(n))
    throw new Error(`Wrong integer: ${n}`);
}
function isBytes2(a) {
  return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
}
function chain(...args) {
  const id = (a) => a;
  const wrap = (a, b) => (c) => a(b(c));
  const encode = args.map((x) => x.encode).reduceRight(wrap, id);
  const decode = args.map((x) => x.decode).reduce(wrap, id);
  return { encode, decode };
}
function alphabet(alphabet2) {
  return {
    encode: (digits) => {
      if (!Array.isArray(digits) || digits.length && typeof digits[0] !== "number")
        throw new Error("alphabet.encode input should be an array of numbers");
      return digits.map((i) => {
        assertNumber(i);
        if (i < 0 || i >= alphabet2.length)
          throw new Error(`Digit index outside alphabet: ${i} (alphabet: ${alphabet2.length})`);
        return alphabet2[i];
      });
    },
    decode: (input) => {
      if (!Array.isArray(input) || input.length && typeof input[0] !== "string")
        throw new Error("alphabet.decode input should be array of strings");
      return input.map((letter) => {
        if (typeof letter !== "string")
          throw new Error(`alphabet.decode: not string element=${letter}`);
        const index = alphabet2.indexOf(letter);
        if (index === -1)
          throw new Error(`Unknown letter: "${letter}". Allowed: ${alphabet2}`);
        return index;
      });
    }
  };
}
function join(separator = "") {
  if (typeof separator !== "string")
    throw new Error("join separator should be string");
  return {
    encode: (from) => {
      if (!Array.isArray(from) || from.length && typeof from[0] !== "string")
        throw new Error("join.encode input should be array of strings");
      for (let i of from)
        if (typeof i !== "string")
          throw new Error(`join.encode: non-string input=${i}`);
      return from.join(separator);
    },
    decode: (to) => {
      if (typeof to !== "string")
        throw new Error("join.decode input should be string");
      return to.split(separator);
    }
  };
}
function padding(bits, chr = "=") {
  assertNumber(bits);
  if (typeof chr !== "string")
    throw new Error("padding chr should be string");
  return {
    encode(data) {
      if (!Array.isArray(data) || data.length && typeof data[0] !== "string")
        throw new Error("padding.encode input should be array of strings");
      for (let i of data)
        if (typeof i !== "string")
          throw new Error(`padding.encode: non-string input=${i}`);
      while (data.length * bits % 8)
        data.push(chr);
      return data;
    },
    decode(input) {
      if (!Array.isArray(input) || input.length && typeof input[0] !== "string")
        throw new Error("padding.encode input should be array of strings");
      for (let i of input)
        if (typeof i !== "string")
          throw new Error(`padding.decode: non-string input=${i}`);
      let end = input.length;
      if (end * bits % 8)
        throw new Error("Invalid padding: string should have whole number of bytes");
      for (; end > 0 && input[end - 1] === chr; end--) {
        if (!((end - 1) * bits % 8))
          throw new Error("Invalid padding: string has too much padding");
      }
      return input.slice(0, end);
    }
  };
}
function normalize(fn) {
  if (typeof fn !== "function")
    throw new Error("normalize fn should be function");
  return { encode: (from) => from, decode: (to) => fn(to) };
}
function convertRadix(data, from, to) {
  if (from < 2)
    throw new Error(`convertRadix: wrong from=${from}, base cannot be less than 2`);
  if (to < 2)
    throw new Error(`convertRadix: wrong to=${to}, base cannot be less than 2`);
  if (!Array.isArray(data))
    throw new Error("convertRadix: data should be array");
  if (!data.length)
    return [];
  let pos = 0;
  const res = [];
  const digits = Array.from(data);
  digits.forEach((d) => {
    assertNumber(d);
    if (d < 0 || d >= from)
      throw new Error(`Wrong integer: ${d}`);
  });
  while (true) {
    let carry = 0;
    let done = true;
    for (let i = pos; i < digits.length; i++) {
      const digit = digits[i];
      const digitBase = from * carry + digit;
      if (!Number.isSafeInteger(digitBase) || from * carry / from !== carry || digitBase - digit !== from * carry) {
        throw new Error("convertRadix: carry overflow");
      }
      carry = digitBase % to;
      const rounded = Math.floor(digitBase / to);
      digits[i] = rounded;
      if (!Number.isSafeInteger(rounded) || rounded * to + carry !== digitBase)
        throw new Error("convertRadix: carry overflow");
      if (!done)
        continue;
      else if (!rounded)
        pos = i;
      else
        done = false;
    }
    res.push(carry);
    if (done)
      break;
  }
  for (let i = 0; i < data.length - 1 && data[i] === 0; i++)
    res.push(0);
  return res.reverse();
}
var gcd = (a, b) => !b ? a : gcd(b, a % b);
var radix2carry = (from, to) => from + (to - gcd(from, to));
function convertRadix2(data, from, to, padding2) {
  if (!Array.isArray(data))
    throw new Error("convertRadix2: data should be array");
  if (from <= 0 || from > 32)
    throw new Error(`convertRadix2: wrong from=${from}`);
  if (to <= 0 || to > 32)
    throw new Error(`convertRadix2: wrong to=${to}`);
  if (radix2carry(from, to) > 32) {
    throw new Error(`convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry(from, to)}`);
  }
  let carry = 0;
  let pos = 0;
  const mask = 2 ** to - 1;
  const res = [];
  for (const n of data) {
    assertNumber(n);
    if (n >= 2 ** from)
      throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);
    carry = carry << from | n;
    if (pos + from > 32)
      throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);
    pos += from;
    for (; pos >= to; pos -= to)
      res.push((carry >> pos - to & mask) >>> 0);
    carry &= 2 ** pos - 1;
  }
  carry = carry << to - pos & mask;
  if (!padding2 && pos >= from)
    throw new Error("Excess padding");
  if (!padding2 && carry)
    throw new Error(`Non-zero padding: ${carry}`);
  if (padding2 && pos > 0)
    res.push(carry >>> 0);
  return res;
}
function radix(num) {
  assertNumber(num);
  return {
    encode: (bytes2) => {
      if (!isBytes2(bytes2))
        throw new Error("radix.encode input should be Uint8Array");
      return convertRadix(Array.from(bytes2), 2 ** 8, num);
    },
    decode: (digits) => {
      if (!Array.isArray(digits) || digits.length && typeof digits[0] !== "number")
        throw new Error("radix.decode input should be array of numbers");
      return Uint8Array.from(convertRadix(digits, num, 2 ** 8));
    }
  };
}
function radix2(bits, revPadding = false) {
  assertNumber(bits);
  if (bits <= 0 || bits > 32)
    throw new Error("radix2: bits should be in (0..32]");
  if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32)
    throw new Error("radix2: carry overflow");
  return {
    encode: (bytes2) => {
      if (!isBytes2(bytes2))
        throw new Error("radix2.encode input should be Uint8Array");
      return convertRadix2(Array.from(bytes2), 8, bits, !revPadding);
    },
    decode: (digits) => {
      if (!Array.isArray(digits) || digits.length && typeof digits[0] !== "number")
        throw new Error("radix2.decode input should be array of numbers");
      return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));
    }
  };
}
function unsafeWrapper(fn) {
  if (typeof fn !== "function")
    throw new Error("unsafeWrapper fn should be function");
  return function(...args) {
    try {
      return fn.apply(null, args);
    } catch (e) {
    }
  };
}
var base16 = chain(radix2(4), alphabet("0123456789ABCDEF"), join(""));
var base32 = chain(radix2(5), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), padding(5), join(""));
var base32nopad = chain(radix2(5), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), join(""));
var base32hex = chain(radix2(5), alphabet("0123456789ABCDEFGHIJKLMNOPQRSTUV"), padding(5), join(""));
var base32hexnopad = chain(radix2(5), alphabet("0123456789ABCDEFGHIJKLMNOPQRSTUV"), join(""));
var base32crockford = chain(radix2(5), alphabet("0123456789ABCDEFGHJKMNPQRSTVWXYZ"), join(""), normalize((s) => s.toUpperCase().replace(/O/g, "0").replace(/[IL]/g, "1")));
var base64 = chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), padding(6), join(""));
var base64nopad = chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), join(""));
var base64url = chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), padding(6), join(""));
var base64urlnopad = chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), join(""));
var genBase58 = (abc) => chain(radix(58), alphabet(abc), join(""));
var base58 = genBase58("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
var base58flickr = genBase58("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ");
var base58xrp = genBase58("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz");
var BECH_ALPHABET = chain(alphabet("qpzry9x8gf2tvdw0s3jn54khce6mua7l"), join(""));
var POLYMOD_GENERATORS = [996825010, 642813549, 513874426, 1027748829, 705979059];
function bech32Polymod(pre) {
  const b = pre >> 25;
  let chk = (pre & 33554431) << 5;
  for (let i = 0; i < POLYMOD_GENERATORS.length; i++) {
    if ((b >> i & 1) === 1)
      chk ^= POLYMOD_GENERATORS[i];
  }
  return chk;
}
function bechChecksum(prefix, words, encodingConst = 1) {
  const len = prefix.length;
  let chk = 1;
  for (let i = 0; i < len; i++) {
    const c = prefix.charCodeAt(i);
    if (c < 33 || c > 126)
      throw new Error(`Invalid prefix (${prefix})`);
    chk = bech32Polymod(chk) ^ c >> 5;
  }
  chk = bech32Polymod(chk);
  for (let i = 0; i < len; i++)
    chk = bech32Polymod(chk) ^ prefix.charCodeAt(i) & 31;
  for (let v of words)
    chk = bech32Polymod(chk) ^ v;
  for (let i = 0; i < 6; i++)
    chk = bech32Polymod(chk);
  chk ^= encodingConst;
  return BECH_ALPHABET.encode(convertRadix2([chk % 2 ** 30], 30, 5, false));
}
function genBech32(encoding) {
  const ENCODING_CONST = encoding === "bech32" ? 1 : 734539939;
  const _words = radix2(5);
  const fromWords = _words.decode;
  const toWords = _words.encode;
  const fromWordsUnsafe = unsafeWrapper(fromWords);
  function encode(prefix, words, limit = 90) {
    if (typeof prefix !== "string")
      throw new Error(`bech32.encode prefix should be string, not ${typeof prefix}`);
    if (!Array.isArray(words) || words.length && typeof words[0] !== "number")
      throw new Error(`bech32.encode words should be array of numbers, not ${typeof words}`);
    if (prefix.length === 0)
      throw new TypeError(`Invalid prefix length ${prefix.length}`);
    const actualLength = prefix.length + 7 + words.length;
    if (limit !== false && actualLength > limit)
      throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);
    const lowered = prefix.toLowerCase();
    const sum = bechChecksum(lowered, words, ENCODING_CONST);
    return `${lowered}1${BECH_ALPHABET.encode(words)}${sum}`;
  }
  function decode(str, limit = 90) {
    if (typeof str !== "string")
      throw new Error(`bech32.decode input should be string, not ${typeof str}`);
    if (str.length < 8 || limit !== false && str.length > limit)
      throw new TypeError(`Wrong string length: ${str.length} (${str}). Expected (8..${limit})`);
    const lowered = str.toLowerCase();
    if (str !== lowered && str !== str.toUpperCase())
      throw new Error(`String must be lowercase or uppercase`);
    const sepIndex = lowered.lastIndexOf("1");
    if (sepIndex === 0 || sepIndex === -1)
      throw new Error(`Letter "1" must be present between prefix and data only`);
    const prefix = lowered.slice(0, sepIndex);
    const data = lowered.slice(sepIndex + 1);
    if (data.length < 6)
      throw new Error("Data must be at least 6 characters long");
    const words = BECH_ALPHABET.decode(data).slice(0, -6);
    const sum = bechChecksum(prefix, words, ENCODING_CONST);
    if (!data.endsWith(sum))
      throw new Error(`Invalid checksum in ${str}: expected "${sum}"`);
    return { prefix, words };
  }
  const decodeUnsafe = unsafeWrapper(decode);
  function decodeToBytes(str) {
    const { prefix, words } = decode(str, false);
    return { prefix, words, bytes: fromWords(words) };
  }
  return { encode, decode, decodeToBytes, decodeUnsafe, fromWords, fromWordsUnsafe, toWords };
}
var bech32 = genBech32("bech32");
var bech32m = genBech32("bech32m");
var hex = chain(radix2(4), alphabet("0123456789abcdef"), join(""), normalize((s) => {
  if (typeof s !== "string" || s.length % 2)
    throw new TypeError(`hex.decode: expected string, got ${typeof s} with length ${s.length}`);
  return s.toLowerCase();
}));

// node_modules/hypersdk-client/src/testdata/abi.abi.json
var abi_abi_default = {
  actions: [
    {
      id: 0,
      name: "ABI"
    }
  ],
  outputs: [],
  types: [
    {
      name: "ABI",
      fields: [
        {
          name: "actions",
          type: "[]TypedStruct"
        },
        {
          name: "outputs",
          type: "[]TypedStruct"
        },
        {
          name: "types",
          type: "[]Type"
        }
      ]
    },
    {
      name: "TypedStruct",
      fields: [
        {
          name: "id",
          type: "uint8"
        },
        {
          name: "name",
          type: "string"
        }
      ]
    },
    {
      name: "Type",
      fields: [
        {
          name: "name",
          type: "string"
        },
        {
          name: "fields",
          type: "[]Field"
        }
      ]
    },
    {
      name: "Field",
      fields: [
        {
          name: "name",
          type: "string"
        },
        {
          name: "type",
          type: "string"
        }
      ]
    }
  ]
};

// node_modules/hypersdk-client/src/Marshaler.ts
var ED25519_AUTH_ID = 0;
var Marshaler = class _Marshaler {
  constructor(abi) {
    this.abi = abi;
    var _a, _b;
    if (!Array.isArray((_a = this.abi) == null ? void 0 : _a.actions) || !Array.isArray((_b = this.abi) == null ? void 0 : _b.outputs)) {
      throw new Error("Invalid ABI");
    }
  }
  getHash() {
    const abiAbiMarshaler = new _Marshaler(abi_abi_default);
    const abiBytes = abiAbiMarshaler.encode("ABI", JSON.stringify(this.abi));
    return sha256(abiBytes);
  }
  encode(typeName, dataJSON) {
    const data = parse(dataJSON);
    return this.encodeField(typeName, data);
  }
  encodeTyped(typeName, dataJSON) {
    var _a;
    const data = parse(dataJSON);
    const typeABI = this.abi.types.find((type) => type.name === typeName);
    if (!typeABI) {
      throw new Error(`Type ${typeName} not found in ABI`);
    }
    const extraFields = Object.keys(data).filter((key) => !typeABI.fields.some((field) => field.name === key));
    if (extraFields.length > 0) {
      throw new Error(`Extra fields found in data: ${extraFields.join(", ")}`);
    }
    const typeId = (_a = [...this.abi.actions, ...this.abi.outputs].find((typ) => typ.name === typeName)) == null ? void 0 : _a.id;
    if (typeId === void 0) {
      throw new Error(`Type ID not found for ${typeName}`);
    }
    const encodedData = this.encodeField(typeName, data);
    return new Uint8Array([typeId, ...encodedData]);
  }
  parseTyped(binary, typeCategory) {
    if (binary.length === 0) {
      throw new Error("Empty binary data");
    }
    const typeId = binary[0];
    const data = binary.slice(1);
    const typeList = typeCategory === "action" ? this.abi.actions : this.abi.outputs;
    const foundType = typeList.find((typ) => typ.id === typeId);
    if (!foundType) {
      console.log(typeList);
      throw new Error(`No ${typeCategory} found for id ${typeId}`);
    }
    return this.parse(foundType.name, data);
  }
  parse(outputType, actionResultBinary) {
    if (isPrimitiveType(outputType)) {
      return this.decodeField(outputType, actionResultBinary);
    }
    let structABI = this.abi.types.find((type) => type.name === outputType);
    if (!structABI) {
      throw new Error(`No struct ABI found for type ${outputType}`);
    }
    let result = {};
    let offset = 0;
    for (const field of structABI.fields) {
      const fieldType = field.type;
      const [decodedValue, bytesConsumed] = this.decodeField(fieldType, actionResultBinary.subarray(offset));
      result[field.name] = decodedValue;
      offset += bytesConsumed;
    }
    return [result, offset];
  }
  decodeField(type, binaryData) {
    switch (type) {
      case "bool":
        return decodeBool(binaryData);
      case "[]uint8":
        return decodeBytes(binaryData);
      case "uint8":
      case "uint16":
      case "uint32":
      case "uint64":
      case "uint256":
        return [decodeNumber(type, binaryData), getByteSize(type)];
      case "string":
        return decodeString(binaryData);
      case "Address":
        return decodeAddress(binaryData);
      case "int8":
      case "int16":
      case "int32":
      case "int64":
        return [decodeNumber(type, binaryData), getByteSize(type)];
      default:
        if (type.startsWith("[]")) {
          return this.decodeSlice(type.slice(2), binaryData);
        } else if (type.startsWith("[")) {
          const match = type.match(/^\[(\d+)\](.+)$/);
          if (match && match[1] && match[2]) {
            const length = parseInt(match[1], 10);
            const elementType = match[2];
            return this.decodeArray(elementType, binaryData, length);
          } else {
            throw new Error(`Unsupported type: ${type}`);
          }
        } else {
          const [decodedStruct, _] = this.parse(type, binaryData);
          const bytesConsumed = this.getStructByteSize(type, binaryData);
          return [decodedStruct, bytesConsumed];
        }
    }
  }
  decodeSlice(type, binaryData) {
    const length = decodeNumber("uint32", binaryData);
    const [resultArray, offset] = this.decodeArray(type, binaryData.subarray(4), length);
    return [resultArray, offset + 4];
  }
  decodeArray(type, binaryData, length) {
    let offset = 0;
    let resultArray = [];
    for (let i = 0; i < length; i++) {
      const [decodedValue, bytesConsumed] = this.decodeField(type, binaryData.subarray(offset));
      resultArray.push(decodedValue);
      offset += bytesConsumed;
    }
    return [resultArray, offset];
  }
  getStructByteSize(type, binaryData) {
    const structABI = this.abi.types.find((t) => t.name === type);
    if (!structABI) {
      throw new Error(`No struct ABI found for type ${type}`);
    }
    let totalSize = 0;
    for (const field of structABI.fields) {
      const [_, bytesConsumed] = this.decodeField(field.type, binaryData.subarray(totalSize));
      totalSize += bytesConsumed;
    }
    return totalSize;
  }
  encodeTransaction(tx) {
    if (tx.base.timestamp.slice(-3) !== "000") {
      tx.base.timestamp = String(Math.floor(parseInt(tx.base.timestamp) / 1e3) * 1e3);
    }
    const timestampBytes = encodeNumber("uint64", tx.base.timestamp);
    const chainIdBytes = encodeNumber("uint256", tx.base.chainId);
    const maxFeeBytes = encodeNumber("uint64", tx.base.maxFee);
    const actionsCountBytes = encodeNumber("uint8", tx.actions.length);
    let actionsBytes = new Uint8Array();
    for (const action of tx.actions) {
      const actionTypeIdBytes = encodeNumber("uint8", this.getActionTypeId(action.actionName));
      const actionDataBytes = this.encodeField(action.actionName, action.data);
      actionsBytes = new Uint8Array([...actionsBytes, ...actionTypeIdBytes, ...actionDataBytes]);
    }
    return new Uint8Array([
      // ...abiHashBytes //TODO: add abi hash to the end of the signable body of transaction
      ...timestampBytes,
      ...chainIdBytes,
      ...maxFeeBytes,
      ...actionsCountBytes,
      ...actionsBytes
    ]);
  }
  decodeTransaction(tx) {
    let offset = 0;
    let timestamp;
    let bytesConsumed;
    [timestamp, bytesConsumed] = this.decodeField("uint64", tx.slice(offset));
    offset += bytesConsumed;
    let chainIdBase64;
    [chainIdBase64, bytesConsumed] = this.decodeField("[32]uint8", tx.slice(offset));
    offset += bytesConsumed;
    let maxFee;
    [maxFee, bytesConsumed] = this.decodeField("uint64", tx.slice(offset));
    offset += bytesConsumed;
    let actionsCount;
    [actionsCount, bytesConsumed] = this.decodeField("uint8", tx.slice(offset));
    offset += bytesConsumed;
    let actions = [];
    for (let i = 0; i < actionsCount; i++) {
      const [action, bytesConsumed2] = this.parseTyped(tx.slice(offset), "action");
      actions.push(action);
      offset += bytesConsumed2;
    }
    return [{
      base: {
        timestamp: timestamp.toString(),
        chainId: chainIdBase64,
        //FIXME: might be a mistake here
        maxFee: maxFee.toString()
      },
      actions
    }, offset];
  }
  getActionTypeId(actionName) {
    const actionABI = this.abi.actions.find((action) => action.name === actionName);
    if (!actionABI) throw new Error(`No action ABI found: ${actionName}`);
    return actionABI.id;
  }
  encodeField(type, value, parentActionName) {
    if (type === "Address" && typeof value === "string") {
      return encodeAddress(value);
    }
    if (type === "[]uint8" && typeof value === "string") {
      const byteArray = Array.from(atob(value), (char) => char.charCodeAt(0));
      return new Uint8Array([...encodeNumber("uint32", byteArray.length), ...byteArray]);
    }
    if (type.startsWith("[]")) {
      return this.encodeSlice(type.slice(2), value);
    } else if (type.startsWith("[")) {
      const match = type.match(/^\[(\d+)\](.+)$/);
      if (match && match[1] && match[2]) {
        const length = parseInt(match[1], 10);
        const elementType = match[2];
        return this.encodeArray(elementType, value, length);
      } else {
        throw new Error(`Unsupported type: ${type}`);
      }
    }
    switch (type) {
      case "bool":
        return encodeBool(value);
      case "uint8":
      case "uint16":
      case "uint32":
      case "uint64":
      case "int8":
      case "int16":
      case "int32":
      case "int64":
        return encodeNumber(type, value);
      case "string":
        return encodeString(value);
      default: {
        let structABI = null;
        for (const typ of this.abi.types) {
          if (typ.name === type) {
            structABI = typ;
            break;
          }
        }
        if (!structABI) throw new Error(`No struct ${type} found in action ${type} ABI`);
        const dataRecord = value;
        let resultingBinary = new Uint8Array();
        for (const field of structABI.fields) {
          const fieldBinary = this.encodeField(field.type, dataRecord[field.name], type);
          resultingBinary = new Uint8Array([...resultingBinary, ...fieldBinary]);
        }
        return resultingBinary;
      }
    }
  }
  encodeSlice(type, value) {
    if (!Array.isArray(value)) {
      throw new Error(`Error in encodeArray: Expected an array for type ${type}, but received ${typeof value} of declared type ${type}`);
    }
    const lengthBytes = encodeNumber("uint32", value.length);
    return new Uint8Array([...lengthBytes, ...this.encodeArray(type, value, value.length)]);
  }
  encodeArray(type, value, expectedLength) {
    if (value.length !== expectedLength) {
      throw new Error(`Error in encodeArray: Expected an array of length ${expectedLength} for type ${type}, but received an array of length ${value.length}`);
    }
    const encodedItems = value.map((item) => this.encodeField(type, item));
    const flattenedItems = encodedItems.reduce((acc, item) => {
      if (item instanceof Uint8Array) {
        return [...acc, ...item];
      } else if (typeof item === "number") {
        return [...acc, item];
      } else {
        throw new Error(`Unexpected item type in encoded array: ${typeof item}`);
      }
    }, []);
    return new Uint8Array(flattenedItems);
  }
};
function isPrimitiveType(type) {
  const primitiveTypes = [
    "uint8",
    "uint16",
    "uint32",
    "uint64",
    "uint256",
    "int8",
    "int16",
    "int32",
    "int64",
    "string",
    "Address",
    "[]uint8"
  ];
  return primitiveTypes.includes(type) || type.startsWith("[]");
}
function decodeNumber(type, binaryData) {
  const dataView = new DataView(binaryData.buffer, binaryData.byteOffset, binaryData.byteLength);
  let result;
  switch (type) {
    case "uint8":
      result = dataView.getUint8(0);
      break;
    case "uint16":
      result = dataView.getUint16(0, false);
      break;
    case "uint32":
      result = dataView.getUint32(0, false);
      break;
    case "uint64":
      result = dataView.getBigUint64(0, false);
      break;
    case "int8":
      result = dataView.getInt8(0);
      break;
    case "int16":
      result = dataView.getInt16(0, false);
      break;
    case "int32":
      result = dataView.getInt32(0, false);
      break;
    case "int64":
      result = dataView.getBigInt64(0, false);
      break;
    default:
      throw new Error(`Unsupported number type: ${type}`);
  }
  return result;
}
function getByteSize(type) {
  switch (type) {
    case "uint8":
      return 1;
    case "uint16":
      return 2;
    case "uint32":
      return 4;
    case "uint64":
      return 8;
    case "uint256":
      return 32;
    case "int8":
      return 1;
    case "int16":
      return 2;
    case "int32":
      return 4;
    case "int64":
      return 8;
    default:
      throw new Error(`Unknown type for byte size: ${type}`);
  }
}
function decodeString(binaryData) {
  const length = decodeNumber("uint16", binaryData);
  const textDecoder = new TextDecoder();
  const stringBytes = binaryData.subarray(2, 2 + length);
  const result = [textDecoder.decode(stringBytes), 2 + length];
  return result;
}
function decodeAddress(binaryData) {
  if (binaryData.length < 33) {
    throw new Error("Decoding address: has to have 33 bytes length");
  }
  const addressBytes = binaryData.subarray(0, 33);
  const hash = sha256(addressBytes);
  const checksum = hash.slice(-4);
  return ["0x" + bytesToHex(addressBytes) + bytesToHex(checksum), 33];
}
function decodeBytes(binaryData) {
  const length = decodeNumber("uint32", binaryData);
  const byteArray = binaryData.subarray(4, 4 + length);
  const base64String = base64.encode(byteArray);
  return [base64String, 4 + length];
}
function encodeAddress(value) {
  if (!/^0x[0-9a-fA-F]{74}$/.test(value)) {
    throw new Error(`Address must be a 74-character hex string with '0x' prefix: ${value}`);
  }
  const hexWithoutPrefix = value.slice(2);
  const allBytes = hexToBytes(hexWithoutPrefix);
  const addressBytes = allBytes.slice(0, 33);
  const providedChecksum = allBytes.slice(33, 37);
  const hash = sha256(addressBytes);
  const expectedChecksum = hash.slice(-4);
  for (let i = 0; i < 4; i++) {
    if (providedChecksum[i] !== expectedChecksum[i]) {
      throw new Error("Invalid address checksum");
    }
  }
  return addressBytes;
}
function addressBytesFromPubKey(pubKey) {
  return new Uint8Array([ED25519_AUTH_ID, ...sha256(pubKey)]);
}
function addressHexFromPubKey(pubKey) {
  const addressBytes = addressBytesFromPubKey(pubKey);
  const hash = sha256(addressBytes);
  const checksum = hash.slice(-4);
  return "0x" + bytesToHex(addressBytes) + bytesToHex(checksum);
}
function encodeNumber(type, value) {
  let bigValue = BigInt(value);
  let buffer;
  let dataView;
  switch (type) {
    case "uint8":
      buffer = new ArrayBuffer(1);
      dataView = new DataView(buffer);
      dataView.setUint8(0, Number(bigValue));
      break;
    case "uint16":
      buffer = new ArrayBuffer(2);
      dataView = new DataView(buffer);
      dataView.setUint16(0, Number(bigValue), false);
      break;
    case "uint32":
      buffer = new ArrayBuffer(4);
      dataView = new DataView(buffer);
      dataView.setUint32(0, Number(bigValue), false);
      break;
    case "uint64":
      buffer = new ArrayBuffer(8);
      dataView = new DataView(buffer);
      dataView.setBigUint64(0, bigValue, false);
      break;
    case "uint256":
      buffer = new ArrayBuffer(32);
      dataView = new DataView(buffer);
      for (let i = 0; i < 32; i++) {
        dataView.setUint8(31 - i, Number(bigValue & 255n));
        bigValue >>= 8n;
      }
      break;
    case "int8":
      buffer = new ArrayBuffer(1);
      dataView = new DataView(buffer);
      dataView.setInt8(0, Number(bigValue));
      break;
    case "int16":
      buffer = new ArrayBuffer(2);
      dataView = new DataView(buffer);
      dataView.setInt16(0, Number(bigValue), false);
      break;
    case "int32":
      buffer = new ArrayBuffer(4);
      dataView = new DataView(buffer);
      dataView.setInt32(0, Number(bigValue), false);
      break;
    case "int64":
      buffer = new ArrayBuffer(8);
      dataView = new DataView(buffer);
      dataView.setBigInt64(0, bigValue, false);
      break;
    default:
      throw new Error(`Unsupported number type: ${type}`);
  }
  return new Uint8Array(buffer);
}
function encodeString(value) {
  const encoder = new TextEncoder();
  const stringBytes = encoder.encode(value);
  const lengthBytes = encodeNumber("uint16", stringBytes.length);
  return new Uint8Array([...lengthBytes, ...stringBytes]);
}
function encodeBool(value) {
  return new Uint8Array([value ? 1 : 0]);
}
function decodeBool(binaryData) {
  const val = binaryData[0];
  if (val !== 0 && val !== 1) {
    throw new Error(`Invalid boolean value: ${val}. Expected 0 or 1.`);
  }
  const value = val === 1;
  return [value, 1];
}

export {
  bytesToHex,
  hexToBytes,
  utf8ToBytes,
  concatBytes,
  wrapConstructor,
  randomBytes,
  HashMD,
  sha256,
  base64,
  base58,
  ED25519_AUTH_ID,
  Marshaler,
  decodeNumber,
  decodeAddress,
  addressBytesFromPubKey,
  addressHexFromPubKey,
  encodeNumber
};
/*! Bundled license information:

@noble/hashes/esm/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@scure/base/lib/esm/index.js:
  (*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
//# sourceMappingURL=chunk-H4KNAJ47.js.map
