"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.idStringToBigInt = exports.HyperSDKClient = void 0;
const PrivateKeySigner_1 = require("./PrivateKeySigner");
const MetamaskSnapSigner_1 = require("./MetamaskSnapSigner");
const Marshaler_1 = require("./Marshaler");
const HyperSDKHTTPClient_1 = require("./HyperSDKHTTPClient");
const base_1 = require("@scure/base");
const apiTransformers_1 = require("./apiTransformers");
const sha256_1 = require("@noble/hashes/sha256");
// TODO: Implement fee prediction
const DEFAULT_MAX_FEE = 1000000n;
const DECIMALS = 9;
class HyperSDKClient extends EventTarget {
    constructor(apiHost, vmName, vmRPCPrefix) {
        super();
        this.signer = null;
        this.abi = null;
        this.marshaler = null;
        this.blockSubscribers = new Set();
        this.isPollingBlocks = false;
        this.http = new HyperSDKHTTPClient_1.HyperSDKHTTPClient(apiHost, vmName, vmRPCPrefix);
    }
    // Public methods
    async connectWallet(params) {
        this.signer = this.createSigner(params);
        await this.signer.connect();
        this.dispatchEvent(new CustomEvent('signerConnected', { detail: this.signer }));
        return this.signer;
    }
    async sendTransaction(actions) {
        const txPayload = await this.createTransactionPayload(actions);
        const abi = await this.getAbi();
        const signed = await this.getSigner().signTx(txPayload, abi);
        const { txId } = await this.http.sendRawTx(signed);
        return this.waitForTransaction(txId);
    }
    //actorHex is optional, if not provided, the signer's public key will be used
    async executeActions(actions, actorHex) {
        const marshaler = await this.getMarshaler();
        const actionBytesArray = actions.map(action => marshaler.encodeTyped(action.actionName, JSON.stringify(action.data)));
        const actor = actorHex ?? (0, Marshaler_1.addressHexFromPubKey)(this.getSigner().getPublicKey());
        const output = await this.http.executeActions(actionBytesArray, actor);
        return output.map(output => marshaler.parseTyped(base_1.base64.decode(output), "output")[0]);
    }
    async getBalance(address) {
        const result = await this.http.makeVmAPIRequest('balance', { address });
        return BigInt(result.amount); // TODO: Handle potential precision loss
    }
    convertToNativeTokens(formattedBalance) {
        const float = parseFloat(formattedBalance);
        return BigInt(float * 10 ** DECIMALS);
    }
    formatNativeTokens(balance) {
        const divisor = 10n ** BigInt(DECIMALS);
        const quotient = balance / divisor;
        const remainder = balance % divisor;
        const paddedRemainder = remainder.toString().padStart(DECIMALS, '0');
        return `${quotient}.${paddedRemainder}`;
    }
    async getAbi() {
        if (!this.abi) {
            const result = await this.http.makeCoreAPIRequest('getABI');
            this.abi = result.abi;
        }
        return this.abi;
    }
    async getTransactionStatus(txId) {
        const response = await this.http.getTransactionStatus(txId);
        const marshaler = await this.getMarshaler();
        return (0, apiTransformers_1.processAPITxResult)(response, marshaler);
    }
    async listenToBlocks(callback, includeEmpty = false, pollingRateMs = 300) {
        this.blockSubscribers.add(callback);
        if (!this.isPollingBlocks) {
            this.startPollingBlocks(includeEmpty, pollingRateMs);
        }
        return () => {
            this.blockSubscribers.delete(callback);
        };
    }
    // Private methods
    async startPollingBlocks(includeEmpty, pollingRateMs) {
        this.isPollingBlocks = true;
        const marshaler = await this.getMarshaler();
        let currentHeight = -1;
        const fetchNextBlock = async () => {
            if (!this.isPollingBlocks)
                return;
            try {
                const block = currentHeight === -1 ?
                    await this.http.getLatestBlock()
                    : await this.http.getBlockByHeight(currentHeight + 1);
                currentHeight = block.block.block.height;
                if (includeEmpty || block.block.block.txs.length > 0) {
                    const executedBlock = (0, apiTransformers_1.processAPIBlock)(block, marshaler);
                    this.blockSubscribers.forEach(callback => {
                        try {
                            callback(executedBlock);
                        }
                        catch (error) {
                            console.error("Error in block callback", error);
                        }
                    });
                }
                setTimeout(fetchNextBlock, pollingRateMs);
            }
            catch (error) {
                if (error?.message?.includes("block not found")) {
                    setTimeout(fetchNextBlock, pollingRateMs * 2);
                }
                else {
                    console.error(error);
                    setTimeout(fetchNextBlock, pollingRateMs * 2); // Longer delay on error
                }
            }
        };
        fetchNextBlock();
    }
    createSigner(params) {
        switch (params.type) {
            case "ephemeral":
                return new PrivateKeySigner_1.EphemeralSigner();
            case "private-key":
                return new PrivateKeySigner_1.PrivateKeySigner(params.privateKey);
            case "metamask-snap":
                return new MetamaskSnapSigner_1.MetamaskSnapSigner(params.snapId ?? MetamaskSnapSigner_1.DEFAULT_SNAP_ID);
            default:
                throw new Error(`Invalid signer type: ${params.type}`);
        }
    }
    getSigner() {
        if (!this.signer) {
            throw new Error("Signer not connected");
        }
        return this.signer;
    }
    async getMarshaler() {
        if (!this.marshaler) {
            const abi = await this.getAbi();
            this.marshaler = new Marshaler_1.Marshaler(abi);
        }
        return this.marshaler;
    }
    async createTransactionPayload(actions) {
        const { chainId } = await this.http.getNetwork();
        const chainIdBigNumber = idStringToBigInt(chainId);
        return {
            base: {
                timestamp: String(BigInt(Date.now()) + 59n * 1000n),
                chainId: String(chainIdBigNumber),
                maxFee: String(DEFAULT_MAX_FEE),
            },
            actions: actions
        };
    }
    async waitForTransaction(txId, timeout = 55000) {
        const startTime = Date.now();
        let lastError = null;
        for (let i = 0; i < 10; i++) {
            if (Date.now() - startTime > timeout) {
                throw new Error("Transaction wait timed out");
            }
            try {
                return await this.getTransactionStatus(txId);
            }
            catch (error) {
                lastError = error instanceof Error ? error : new Error(String(error));
                if (!(error instanceof Error) || error.message !== "tx not found") {
                    throw error;
                }
            }
            await new Promise(resolve => setTimeout(resolve, 100 * i));
        }
        throw lastError || new Error("Failed to get transaction status");
    }
}
exports.HyperSDKClient = HyperSDKClient;
const cb58 = {
    encode(data) {
        return base_1.base58.encode(new Uint8Array([...data, ...(0, sha256_1.sha256)(data).subarray(-4)]));
    },
    decode(string) {
        return base_1.base58.decode(string).subarray(0, -4);
    },
};
function idStringToBigInt(id) {
    const bytes = cb58.decode(id);
    return BigInt(`0x${bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '')}`);
}
exports.idStringToBigInt = idStringToBigInt;
