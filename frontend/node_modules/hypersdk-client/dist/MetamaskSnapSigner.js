"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MetamaskSnapSigner = exports.DEFAULT_SNAP_ID = void 0;
const base_1 = require("@scure/base");
const sdk_1 = __importDefault(require("@metamask/sdk"));
exports.DEFAULT_SNAP_ID = `npm:hypersdk-snap`;
let cachedProvider = null;
async function getProvider() {
    if (!cachedProvider) {
        const metamaskSDK = new sdk_1.default();
        await metamaskSDK.connect();
        const provider = metamaskSDK.getProvider();
        if (!provider) {
            throw new Error("Failed to get provider");
        }
        cachedProvider = provider;
    }
    return cachedProvider;
}
class MetamaskSnapSigner {
    constructor(snapId) {
        this.snapId = snapId;
        this.cachedPublicKey = null;
    }
    getPublicKey() {
        if (!this.cachedPublicKey) {
            throw new Error("Public key not cached. Please call connect() first.");
        }
        return this.cachedPublicKey;
    }
    async signTx(txPayload, abi) {
        const sig58 = await this._invokeSnap({
            method: 'signTransaction', params: {
                abi: abi,
                tx: txPayload,
            }
        });
        if (!sig58) {
            throw new Error("Failed to sign transaction");
        }
        return base_1.base58.decode(sig58);
    }
    async connect() {
        const provider = await getProvider();
        const providerVersion = (await provider?.request({ method: "web3_clientVersion" })) || "";
        if (!providerVersion.includes("flask")) {
            throw new Error("Your client is not compatible with development snaps. Please install MetaMask Flask!");
        }
        const snaps = (await provider.request({
            method: 'wallet_getSnaps',
        }));
        if (!Object.keys(snaps).includes(this.snapId) || this.snapId.startsWith("local:")) {
            await this.reinstallSnap();
        }
        const pubKey = await this._invokeSnap({
            method: 'getPublicKey',
            params: {}
        });
        if (!pubKey) {
            throw new Error("Failed to get public key");
        }
        this.cachedPublicKey = base_1.base58.decode(pubKey);
    }
    async reinstallSnap() {
        const provider = await getProvider();
        console.log('Installing snap...');
        await provider.request({
            method: 'wallet_requestSnaps',
            params: {
                [this.snapId]: {},
            },
        });
        console.log('Snap installed');
        const snaps = (await provider.request({
            method: 'wallet_getSnaps',
        }));
        if (Object.keys(snaps).includes(this.snapId)) {
            console.log('Snap installed successfully');
        }
        else {
            console.error('Snap not installed');
            throw new Error('Failed to install snap');
        }
    }
    async _invokeSnap({ method, params }) {
        JSON.stringify(params); //PRESERVE THIS! if we can't serialize it, Metamask will fail too
        const provider = await getProvider();
        return await provider.request({
            method: 'wallet_invokeSnap',
            params: {
                snapId: this.snapId,
                request: params ? { method, params } : { method },
            },
        });
    }
}
exports.MetamaskSnapSigner = MetamaskSnapSigner;
